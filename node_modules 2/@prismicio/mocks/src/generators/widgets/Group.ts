import {
	GroupContent,
	GroupContentType,
	GroupItemContent,
	GroupItemContentType,
} from "@prismicio/types-internal/lib/content/fields"
import type { NestableContent } from "@prismicio/types-internal/lib/content/fields/nestable/NestableContent"
import {
	type Group,
	type GroupWidgetDiff,
	type NestableWidget,
	DiffOperation,
} from "@prismicio/types-internal/lib/customtypes"

import type { NestableWidgetMockConfig } from ".."
import type { WidgetMockWithDiff } from "../Mock"
import type { MockConfig } from "../MockConfig"
import { NestableWidgetMock } from "."

export interface GroupMockConfig
	extends MockConfig<Group["type"], Array<Array<[string, NestableContent]>>> {
	nbBlocks?: number
	fields?: Partial<Record<string, NestableWidgetMockConfig>>
}

function random(
	def: Group,
	nbBlocks: number | undefined = 1,
	fields: Partial<Record<string, NestableWidgetMockConfig>> = {},
): Array<Array<[string, NestableContent]>> {
	if (!def.config || !def.config.fields) {
		return []
	}

	return Array(nbBlocks)
		.fill(null)
		.map(() => {
			const defs: Array<[string, NestableWidget]> = Object.entries(
				def?.config?.fields || {},
			)

			const block: Array<[string, NestableContent]> = defs.map(
				([key, field]: [string, NestableWidget]) => {
					const mockConfig = fields[key]
					return [key, NestableWidgetMock.generate(field, mockConfig)]
				},
			)
			return block
		})
}

export const GroupMock: WidgetMockWithDiff<
	Group,
	GroupContent,
	GroupMockConfig
> = {
	generate(def: Group, config?: GroupMockConfig): GroupContent {
		const value = config?.value || random(def, config?.nbBlocks, config?.fields)

		return {
			__TYPE__: GroupContentType,
			value: value.map((item) => ({
				__TYPE__: GroupItemContentType,
				value: item,
			})),
		} as GroupContent
	},

	patch(
		diff: GroupWidgetDiff,
		content?: GroupContent,
		config?: GroupMockConfig,
	) {
		if (diff.op === DiffOperation.Removed) return

		// Retrieve group item values or create empty new ones after mock config
		const items: GroupItemContent[] =
			content?.value ||
			Array<GroupItemContent>(config?.nbBlocks || 1).fill({
				__TYPE__: GroupItemContentType,
				value: [],
			})

		// Patch each group item values
		const patched = items.map((item) => {
			// Take current group item value
			const valueObject = Object.fromEntries(item.value)

			// Patch each group item widget value
			Object.entries(diff.value.config.fields ?? {}).forEach(
				([key, fieldDiff]) => {
					const patchedWidget = NestableWidgetMock.patch(
						fieldDiff,
						valueObject[key],
						config?.fields?.[key],
					)

					if (patchedWidget) {
						// If the widget was patched, update the group item widget value
						valueObject[key] = patchedWidget
					} else {
						// If the widget was removed, delete it from the group item value
						delete valueObject[key]
					}
				},
			)

			return {
				__TYPE__: GroupItemContentType,
				value: Object.entries(valueObject),
			}
		})

		return {
			__TYPE__: GroupContentType,
			value: patched,
		}
	},
}
