"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupMock = void 0;
const fields_1 = require("@prismicio/types-internal/lib/content/fields");
const customtypes_1 = require("@prismicio/types-internal/lib/customtypes");
const _1 = require(".");
function random(def, nbBlocks = 1, fields = {}) {
    if (!def.config || !def.config.fields) {
        return [];
    }
    return Array(nbBlocks)
        .fill(null)
        .map(() => {
        var _a;
        const defs = Object.entries(((_a = def === null || def === void 0 ? void 0 : def.config) === null || _a === void 0 ? void 0 : _a.fields) || {});
        const block = defs.map(([key, field]) => {
            const mockConfig = fields[key];
            return [key, _1.NestableWidgetMock.generate(field, mockConfig)];
        });
        return block;
    });
}
exports.GroupMock = {
    generate(def, config) {
        const value = (config === null || config === void 0 ? void 0 : config.value) || random(def, config === null || config === void 0 ? void 0 : config.nbBlocks, config === null || config === void 0 ? void 0 : config.fields);
        return {
            __TYPE__: fields_1.GroupContentType,
            value: value.map((item) => ({
                __TYPE__: fields_1.GroupItemContentType,
                value: item,
            })),
        };
    },
    patch(diff, content, config) {
        if (diff.op === customtypes_1.DiffOperation.Removed)
            return;
        // Retrieve group item values or create empty new ones after mock config
        const items = (content === null || content === void 0 ? void 0 : content.value) ||
            Array((config === null || config === void 0 ? void 0 : config.nbBlocks) || 1).fill({
                __TYPE__: fields_1.GroupItemContentType,
                value: [],
            });
        // Patch each group item values
        const patched = items.map((item) => {
            var _a;
            // Take current group item value
            const valueObject = Object.fromEntries(item.value);
            // Patch each group item widget value
            Object.entries((_a = diff.value.config.fields) !== null && _a !== void 0 ? _a : {}).forEach(([key, fieldDiff]) => {
                var _a;
                const patchedWidget = _1.NestableWidgetMock.patch(fieldDiff, valueObject[key], (_a = config === null || config === void 0 ? void 0 : config.fields) === null || _a === void 0 ? void 0 : _a[key]);
                if (patchedWidget) {
                    // If the widget was patched, update the group item widget value
                    valueObject[key] = patchedWidget;
                }
                else {
                    // If the widget was removed, delete it from the group item value
                    delete valueObject[key];
                }
            });
            return {
                __TYPE__: fields_1.GroupItemContentType,
                value: Object.entries(valueObject),
            };
        });
        return {
            __TYPE__: fields_1.GroupContentType,
            value: patched,
        };
    },
};
