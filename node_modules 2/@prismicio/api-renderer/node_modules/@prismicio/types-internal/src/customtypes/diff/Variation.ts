import { Objects } from "../../utils"
import type { NestableWidget } from "../widgets/nestable"
import type { SlicePrimaryWidget } from "../widgets/slices"
import type { Variation } from "../widgets/slices"
import { type DiffChange, DiffOperation } from "./Changes"

export type VariationMetadata = Omit<Variation, "primary" | "items">
export type VariationDiff = DiffChange<
	Variation,
	Partial<VariationMetadata> & {
		primary?: Record<string, DiffChange<SlicePrimaryWidget, SlicePrimaryWidget>>
		items?: Record<string, DiffChange<NestableWidget, NestableWidget>>
	}
>

function compareVariationMeta(
	variationA?: Variation,
	variationB?: Variation,
): Partial<VariationMetadata> {
	const zippedVariations = Objects.zipObjects(variationA, variationB)

	return Object.entries(zippedVariations).reduce((acc, [key, value]) => {
		if (key === `primary` || key === "items") return acc

		if (value?.left === value?.right) return acc
		return { ...acc, [key]: value?.right }
	}, {})
}

function compareWidgets<TWidget extends NestableWidget | SlicePrimaryWidget>(
	widgetsA?: { [key: string]: TWidget },
	widgetsB?: { [key: string]: TWidget },
): Record<string, DiffChange<TWidget, TWidget>> | undefined {
	const zippedWidgets = Objects.zipObjects(widgetsA, widgetsB)

	const diffWidgets = Object.entries(zippedWidgets).reduce(
		(acc, [widgetKey, widgetValue]) => {
			if (
				JSON.stringify(widgetValue?.left) === JSON.stringify(widgetValue?.right)
			)
				return acc

			const changes = (() => {
				if (!widgetValue?.left && !widgetValue?.right) return
				if (widgetValue?.left && !widgetValue.right)
					return {
						op: DiffOperation.Removed,
					}
				if (!widgetValue?.left && widgetValue?.right)
					return {
						op: DiffOperation.Added,
						value: widgetValue.right,
					}
				return {
					op: DiffOperation.Updated,
					value: widgetValue.right,
				}
			})()

			if (!changes) return acc

			return {
				...acc,
				[widgetKey]: changes,
			}
		},
		{},
	)

	return Objects.isNotEmpty(diffWidgets) ? diffWidgets : undefined
}

export const VariationComparator = {
	compare(
		variationA?: Variation,
		variationB?: Variation,
	): VariationDiff | undefined {
		if (variationA && !variationB)
			return {
				op: DiffOperation.Removed,
			}
		if (!variationA && variationB) {
			return {
				op: DiffOperation.Added,
				value: variationB,
			}
		}

		const diffMeta = compareVariationMeta(variationA, variationB)

		const diffPrimary = compareWidgets(variationA?.primary, variationB?.primary)
		const diffItems = compareWidgets(variationA?.items, variationB?.items)

		const diffVariation = {
			...diffMeta,
			...(diffPrimary ? { primary: diffPrimary } : {}),
			...(diffItems ? { items: diffItems } : {}),
		}

		if (Objects.isNotEmpty(diffVariation)) {
			return {
				op: DiffOperation.Updated,
				value: diffVariation,
			}
		}
		return undefined
	},
}
