import {
	EmptyContent,
	isBooleanContent,
	isColorContent,
	isDateContent,
	isEmbedContent,
	isGeoPointContent,
	isImageContent,
	isIntegrationFieldContent,
	isLinkContent,
	isNumberContent,
	isRangeContent,
	isRichTextContent,
	isSelectContent,
	isSeparatorContent,
	isTextContent,
	isTimestampContent,
	isUIDContent,
	NestableContent,
} from "@prismicio/types-internal/lib/content"
import type {
	Color,
	Date as DateDef,
	NestableWidget,
	Number as NumberDef,
	Range,
	Select,
	Text,
	Timestamp,
} from "@prismicio/types-internal/lib/customtypes"
import { compact } from "fp-ts/lib/Array"
import * as O from "fp-ts/lib/Option"

import type { RenderContext } from "../models"
import type { Renderer } from "../models"
import { DocRelation, DocRelationType, Field, SimpleField, SimpleFieldType } from "../models/fetch"
import { renderIfNoFetchOrFetchDefined } from "../utils"
import {
	BooleanRenderer,
	EmbedRenderer,
	FieldRenderer,
	GeoPointRenderer,
	ImageRenderer,
	IntegrationFieldsRenderer,
	LinkRenderer,
	SeparatorRenderer,
	StructuredTextRenderer,
} from "./nestable"
import UIDRenderer from "./UIDRenderer"

function extractSimpleFieldIfAny(field: Field | undefined): SimpleField | undefined {
	if (field !== undefined && field.TYPE === SimpleFieldType) {
		return field
	} else {
		return undefined
	}
}

function extractFetchDocRelationIfAny(field: Field | undefined): DocRelation | undefined {
	if (field !== undefined && field.TYPE === DocRelationType) {
		return field
	} else {
		return undefined
	}
}

const SimpleWidgetRenderer: (ctx: RenderContext) => Renderer<NestableWidget, NestableContent, Field> & {
	renderObjectOfSimpleWidgetV1(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fetch: Record<string, Field> | undefined,
	): object
	renderObjectOfSimpleWidgetV2(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fetch: Record<string, Field> | undefined,
		fieldsDef: Record<string, NestableWidget>,
		renderIfUndefined: {
			withFetch: "default" | "filter"
		},
		renderIfNull: {
			default: "default" | "render" | "filter"
			withFetch: "default" | "filter"
			withFetchField: "default" | "render" | "filter"
		},
	): Record<string, unknown>
	renderObjectOfSimpleWidgetMocks(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fieldsDef: Record<string, NestableWidget>,
	): Record<string, unknown>
} = (ctx) => ({
	renderV1(content: NestableContent, fetch: Field | undefined): unknown {
		if (isRichTextContent(content)) {
			return StructuredTextRenderer(ctx).renderV1(content, extractSimpleFieldIfAny(fetch))
		} else if (isImageContent(content)) {
			return ImageRenderer(ctx).renderV1(content)
		} else if (
			// We should split the renderers of each
			isRangeContent(content) ||
			isNumberContent(content) ||
			isTimestampContent(content) ||
			isDateContent(content) ||
			isTextContent(content) ||
			isColorContent(content) ||
			isSelectContent(content)
		) {
			return FieldRenderer.renderV1(content)
		} else if (isLinkContent(content)) {
			return LinkRenderer(ctx).renderV1(content, extractFetchDocRelationIfAny(fetch))
		} else if (isEmbedContent(content)) {
			return EmbedRenderer.renderV1(content)
		} else if (isGeoPointContent(content)) {
			return GeoPointRenderer.renderV1(content)
		} else if (isUIDContent(content)) {
			return UIDRenderer.renderV1(content)
		} else if (isIntegrationFieldContent(content)) {
			return IntegrationFieldsRenderer(ctx).renderV1(content)
		} else if (isSeparatorContent(content)) {
			return SeparatorRenderer.renderV1(content)
		} else if (isBooleanContent(content)) {
			return BooleanRenderer.renderV1(content)
		} else {
			return null
		}
	},

	renderV2(def: NestableWidget, content: NestableContent, fetch: Field | undefined): unknown {
		if (def.type === "StructuredText" && isRichTextContent(content)) {
			return StructuredTextRenderer(ctx).renderV2(def, content, extractSimpleFieldIfAny(fetch))
		} else if (def.type === "Image" && isImageContent(content)) {
			return ImageRenderer(ctx).renderV2(def, content)
		} else if (def.type === "Link" && isLinkContent(content)) {
			return LinkRenderer(ctx).renderV2(def, content, extractFetchDocRelationIfAny(fetch))
		} else if (def.type === "Embed" && isEmbedContent(content)) {
			return EmbedRenderer.renderV2(def, content)
		} else if (def.type === "GeoPoint" && isGeoPointContent(content)) {
			return GeoPointRenderer.renderV2(def, content)
		} else if (def.type === "IntegrationFields" && isIntegrationFieldContent(content)) {
			return IntegrationFieldsRenderer(ctx).renderV2(def, content)
		} else if (def.type === "Separator" && isSeparatorContent(content)) {
			return SeparatorRenderer.renderV2(def, content)
		} else if (def.type === "Boolean" && isBooleanContent(content)) {
			return BooleanRenderer.renderV2(def, content)
		} else if (
			isRangeContent(content) ||
			isNumberContent(content) ||
			isTimestampContent(content) ||
			isDateContent(content) ||
			isTextContent(content) ||
			isColorContent(content) ||
			isSelectContent(content)
		) {
			// TODO: because of an old bug, we have to cast the type here to maintain backward compatibility
			// We should check that `def.type` is matching FieldDef or fallback to the null case.
			return FieldRenderer.renderV2(def as Color | NumberDef | DateDef | Timestamp | Select | Text | Range, content)
		} else {
			return null
		}
	},

	renderDefault(def: NestableWidget): unknown {
		if (def.type === "Link") {
			return LinkRenderer(ctx).renderDefault(def)
		} else if (def.type === "Embed") {
			return EmbedRenderer.renderDefault(def)
		} else if (def.type === "GeoPoint") {
			return GeoPointRenderer.renderDefault(def)
		} else if (def.type === "StructuredText") {
			return StructuredTextRenderer(ctx).renderDefault(def)
		} else if (def.type === "Image") {
			return ImageRenderer(ctx).renderDefault(def)
		} else if (def.type === "Separator") {
			return SeparatorRenderer.renderDefault(def)
		} else if (def.type === "Boolean") {
			return BooleanRenderer.renderDefault(def)
		} else if (def.type === "IntegrationFields") {
			return IntegrationFieldsRenderer(ctx).renderDefault(def)
		} else {
			return FieldRenderer.renderDefault(def)
		}
	},

	renderMocks(def: NestableWidget, content: NestableContent): unknown {
		if (def.type === "StructuredText" && isRichTextContent(content)) {
			return StructuredTextRenderer(ctx).renderMocks(def, content)
		} else if (def.type === "Image" && isImageContent(content)) {
			return ImageRenderer(ctx).renderMocks(def, content)
		} else if (def.type === "Link" && isLinkContent(content)) {
			return LinkRenderer(ctx).renderMocks(def, content)
		} else if (def.type === "Embed" && isEmbedContent(content)) {
			return EmbedRenderer.renderMocks(def, content)
		} else if (def.type === "GeoPoint" && isGeoPointContent(content)) {
			return GeoPointRenderer.renderMocks(def, content)
		} else if (def.type === "IntegrationFields" && isIntegrationFieldContent(content)) {
			return IntegrationFieldsRenderer(ctx).renderMocks(def, content)
		} else if (def.type === "Separator" && isSeparatorContent(content)) {
			return SeparatorRenderer.renderMocks(def, content)
		} else if (def.type === "Boolean" && isBooleanContent(content)) {
			return BooleanRenderer.renderMocks(def, content)
		} else if (
			(isRangeContent(content) && def.type === "Range") ||
			(isNumberContent(content) && def.type === "Number") ||
			(isTimestampContent(content) && def.type === "Timestamp") ||
			(isDateContent(content) && def.type === "Date") ||
			(isTextContent(content) && def.type === "Text") ||
			(isColorContent(content) && def.type === "Color") ||
			(isSelectContent(content) && def.type === "Select")
		) {
			return FieldRenderer.renderMocks(def, content)
		} else {
			return null
		}
	},

	renderObjectOfSimpleWidgetV1(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fetch: Record<string, Field> | undefined,
	): object {
		const c: Array<[string, NestableContent]> = content instanceof Array ? content : Object.entries(content)

		return Object.fromEntries(
			compact(
				c.map(([key, widget]) => {
					if (EmptyContent.is(widget)) {
						return O.none
					}

					return renderIfNoFetchOrFetchDefined(fetch, key, (f: Field | undefined) =>
						O.some([key, this.renderV1(widget, f)]),
					)
				}),
			),
		)
	},

	renderObjectOfSimpleWidgetV2(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fetch: Record<string, Field> | undefined,
		fieldsDef: Record<string, NestableWidget>,
		renderIfUndefined: {
			withFetch: "default" | "filter"
		},
		renderIfNull: {
			default: "default" | "render" | "filter"
			withFetch: "default" | "filter"
			withFetchField: "default" | "render" | "filter"
		},
	): Record<string, unknown> {
		const itemByKey: Record<string, NestableContent> = content instanceof Array ? Object.fromEntries(content) : content
		const result: Record<string, unknown> = {}

		Object.entries(fieldsDef).forEach(([key, def]) => {
			const item = itemByKey[key]
			if (item === undefined) {
				if ((fetch && key in fetch) || !fetch) {
					result[key] = this.renderDefault(def)
				} else if (fetch) {
					if (renderIfUndefined.withFetch === "default") {
						result[key] = this.renderDefault(def)
					}
				}
			} else if (EmptyContent.is(item)) {
				if (fetch && key in fetch) {
					if (renderIfNull.withFetchField === "default") {
						result[key] = this.renderDefault(def)
					} else if (renderIfNull.withFetchField === "render") {
						result[key] = this.renderV2(def, item, fetch[key])
					}
				} else if (fetch) {
					if (renderIfNull.withFetch === "default") {
						result[key] = this.renderDefault(def)
					}
				} else {
					if (renderIfNull.default === "default") {
						result[key] = this.renderDefault(def)
					} else if (renderIfNull.default === "render") {
						result[key] = this.renderV2(def, item)
					}
				}
			} else {
				const renderedO = renderIfNoFetchOrFetchDefined(fetch, key, (f) => O.some(this.renderV2(def, item, f)))
				if (O.isSome(renderedO)) {
					result[key] = renderedO.value
				}
			}
		})

		return result
	},

	renderObjectOfSimpleWidgetMocks(
		content: Array<[string, NestableContent]> | Record<string, NestableContent>,
		fieldsDef: Record<string, NestableWidget>,
	): Record<string, unknown> {
		const itemByKey: Record<string, NestableContent> = content instanceof Array ? Object.fromEntries(content) : content
		const result: Record<string, unknown> = {}
		Object.entries(fieldsDef).forEach(([name, def]) => {
			const key = name
			const item = itemByKey[key]
			if (item === undefined) {
				result[key] = this.renderDefault(def)
			} else if (EmptyContent.is(item)) {
				result[key] = this.renderDefault(def)
			} else {
				const renderedO = renderIfNoFetchOrFetchDefined(undefined, key, () => O.some(this.renderMocks(def, item)))
				if (O.isSome(renderedO)) {
					result[key] = renderedO.value
				}
			}
		})

		return result
	},
})

export default SimpleWidgetRenderer
