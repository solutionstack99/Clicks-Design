import {
	EmptyContent,
	GroupContent,
	isGroupContent,
	isNestableContent,
	NestableContent,
} from "@prismicio/types-internal/lib/content"
import type { Group as GroupField, NestableWidget } from "@prismicio/types-internal/lib/customtypes"
import { compact } from "fp-ts/lib/Array"
import * as O from "fp-ts/lib/Option"

import type { RenderContext, Renderer } from "../models"
import { Field, Group, GroupOrField, GroupType } from "../models/fetch"
import { renderIfNoFetchOrFetchDefined } from "../utils"
import GroupRenderer from "./GroupRenderer"
import SimpleWidgetRenderer from "./SimpleWidgetRenderer"

function extractFetchGroupIfAny(fetch: GroupOrField | undefined): Group | undefined {
	if (fetch !== undefined && fetch.TYPE === GroupType) {
		return fetch
	} else {
		return undefined
	}
}

function extractFetchFieldIfAny(fetch: GroupOrField | undefined): Field | undefined {
	if (fetch !== undefined && fetch.TYPE !== GroupType) {
		return fetch
	} else {
		return undefined
	}
}

const StaticWidgetRenderer: (ctx: RenderContext) => Renderer<
	NestableWidget | GroupField,
	NestableContent | GroupContent,
	GroupOrField
> & {
	renderObjectOfStaticWidgetV1(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fetch: Record<string, GroupOrField> | undefined,
	): object
	renderObjectOfStaticWidgetV2(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fetch: Record<string, GroupOrField> | undefined,
		fieldsDef: Record<string, NestableWidget | GroupField>,
		renderIfUndefined: {
			withFetch: "default" | "filter"
		},
		renderIfNull: {
			default: "default" | "render" | "filter"
			withFetch: "default" | "filter"
			withFetchField: "default" | "render" | "filter"
		},
	): Record<string, unknown>
	renderObjectOfStaticWidgetMocks(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fieldsDef: Record<string, NestableWidget | GroupField>,
	): Record<string, unknown>
} = (ctx) => ({
	renderV1(content: NestableContent | GroupContent, fetch: GroupOrField | undefined): unknown {
		if (isGroupContent(content)) {
			return GroupRenderer(ctx).renderV1(content, extractFetchGroupIfAny(fetch))
		} else {
			return SimpleWidgetRenderer(ctx).renderV1(content, extractFetchFieldIfAny(fetch))
		}
	},

	renderV2(
		def: NestableWidget | GroupField,
		content: NestableContent | GroupContent,
		fetch: GroupOrField | undefined,
	): unknown {
		if (def.type !== "Group" && isNestableContent(content)) {
			// todo maybe find an other condition
			return SimpleWidgetRenderer(ctx).renderV2(def, content, extractFetchFieldIfAny(fetch))
		} else if (def.type === "Group" && isGroupContent(content)) {
			return GroupRenderer(ctx).renderV2(def, content, extractFetchGroupIfAny(fetch))
		} else {
			return this.renderDefault(def)
		}
	},

	renderDefault(def: NestableWidget | GroupField): unknown {
		if (def.type === "Group") {
			return GroupRenderer(ctx).renderDefault(def)
		} else {
			return SimpleWidgetRenderer(ctx).renderDefault(def)
		}
	},

	renderMocks(def: NestableWidget | GroupField, content: NestableContent | GroupContent): unknown {
		if (isNestableContent(content) && def.type !== "Group") {
			return SimpleWidgetRenderer(ctx).renderMocks(def, content)
		} else if (isGroupContent(content) && def.type === "Group") {
			return GroupRenderer(ctx).renderMocks(def, content)
		} else {
			return this.renderDefault(def)
		}
	},

	renderObjectOfStaticWidgetV1(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fetch: Record<string, GroupOrField> | undefined,
	): object {
		const c: Array<[string, NestableContent | GroupContent]> =
			content instanceof Array ? content : Object.entries(content)

		return Object.fromEntries(
			compact(
				c.map(([key, widget]) => {
					if (EmptyContent.is(widget)) {
						return O.none
					}

					return renderIfNoFetchOrFetchDefined(fetch, key, (f: GroupOrField | undefined) =>
						O.some([key, this.renderV1(widget, f)]),
					)
				}),
			),
		)
	},

	renderObjectOfStaticWidgetV2(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fetch: Record<string, GroupOrField> | undefined,
		fieldsDef: Record<string, NestableWidget | GroupField>,
		renderIfUndefined: {
			withFetch: "default" | "filter"
		},
		renderIfNull: {
			default: "default" | "render" | "filter"
			withFetch: "default" | "filter"
			withFetchField: "default" | "render" | "filter"
		},
	): Record<string, unknown> {
		const itemByKey: Record<string, NestableContent | GroupContent> =
			content instanceof Array ? Object.fromEntries(content) : content
		const result: Record<string, unknown> = {}

		Object.entries(fieldsDef).forEach(([key, def]) => {
			const item = itemByKey[key]
			if (item === undefined) {
				if ((fetch && key in fetch) || !fetch) {
					result[key] = this.renderDefault(def)
				} else if (fetch) {
					if (renderIfUndefined.withFetch === "default") {
						result[key] = this.renderDefault(def)
					}
				}
			} else if (EmptyContent.is(item)) {
				if (fetch && key in fetch) {
					if (renderIfNull.withFetchField === "default") {
						result[key] = this.renderDefault(def)
					} else if (renderIfNull.withFetchField === "render") {
						result[key] = this.renderV2(def, item, fetch[key])
					}
				} else if (fetch) {
					if (renderIfNull.withFetch === "default") {
						result[key] = this.renderDefault(def)
					}
				} else {
					if (renderIfNull.default === "default") {
						result[key] = this.renderDefault(def)
					} else if (renderIfNull.default === "render") {
						result[key] = this.renderV2(def, item)
					}
				}
			} else {
				const renderedO = renderIfNoFetchOrFetchDefined(fetch, key, (f) => O.some(this.renderV2(def, item, f)))
				if (O.isSome(renderedO)) {
					result[key] = renderedO.value
				}
			}
		})

		return result
	},

	renderObjectOfStaticWidgetMocks(
		content: Array<[string, NestableContent | GroupContent]> | Record<string, NestableContent | GroupContent>,
		fieldsDef: Record<string, NestableWidget | GroupField>,
	): Record<string, unknown> {
		const itemByKey: Record<string, NestableContent | GroupContent> =
			content instanceof Array ? Object.fromEntries(content) : content
		const result: Record<string, unknown> = {}
		Object.entries(fieldsDef).forEach(([name, def]) => {
			const key = name
			const item = itemByKey[key]
			if (item === undefined) {
				result[key] = this.renderDefault(def)
			} else if (EmptyContent.is(item)) {
				result[key] = this.renderDefault(def)
			} else {
				const renderedO = renderIfNoFetchOrFetchDefined(undefined, key, () => O.some(this.renderMocks(def, item)))
				if (O.isSome(renderedO)) {
					result[key] = renderedO.value
				}
			}
		})

		return result
	},
})

export default StaticWidgetRenderer
