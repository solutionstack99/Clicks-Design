{"version":3,"file":"parse-proxy-response.cjs","sources":["../../../../../../node_modules/https-proxy-agent/dist/parse-proxy-response.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports.default = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map"],"names":["this","parseProxyResponse_1","require$$0"],"mappings":";;;;AACA,IAAI,kBAAmBA,iBAAI,kBAAIA,iBAAI,eAAC,mBAAoB,SAAU,KAAK;AACnE,SAAQ,OAAO,IAAI,aAAc,MAAM,EAAE,WAAW;AACxD;AACA,OAAO,eAAeC,qBAAAA,WAAS,cAAc,EAAE,OAAO,KAAI,CAAE;AAC5D,MAAM,UAAU,gBAAgBC,QAAAA,cAAgB;AAChD,MAAM,QAAQ,QAAQ,QAAQ,wCAAwC;AACtE,SAAS,mBAAmB,QAAQ;AAChC,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAKpC,QAAI,gBAAgB;AACpB,UAAM,UAAU,CAAA;AAChB,aAAS,OAAO;AACZ,YAAM,IAAI,OAAO;AACjB,UAAI;AACA,eAAO,CAAC;AAAA;AAER,eAAO,KAAK,YAAY,IAAI;AAAA,IACnC;AACD,aAAS,UAAU;AACf,aAAO,eAAe,OAAO,KAAK;AAClC,aAAO,eAAe,SAAS,OAAO;AACtC,aAAO,eAAe,SAAS,OAAO;AACtC,aAAO,eAAe,YAAY,IAAI;AAAA,IACzC;AACD,aAAS,QAAQ,KAAK;AAClB,YAAM,wBAAwB,GAAG;AAAA,IACpC;AACD,aAAS,QAAQ;AACb,YAAM,OAAO;AAAA,IAChB;AACD,aAAS,QAAQ,KAAK;AAClB;AACA,YAAM,cAAc,GAAG;AACvB,aAAO,GAAG;AAAA,IACb;AACD,aAAS,OAAO,GAAG;AACf,cAAQ,KAAK,CAAC;AACd,uBAAiB,EAAE;AACnB,YAAM,WAAW,OAAO,OAAO,SAAS,aAAa;AACrD,YAAM,eAAe,SAAS,QAAQ,UAAU;AAChD,UAAI,iBAAiB,IAAI;AAErB,cAAM,8CAA8C;AACpD;AACA;AAAA,MACH;AACD,YAAM,YAAY,SAAS,SAAS,SAAS,GAAG,SAAS,QAAQ,MAAM,CAAC;AACxE,YAAM,aAAa,CAAC,UAAU,MAAM,GAAG,EAAE,CAAC;AAC1C,YAAM,iCAAiC,SAAS;AAChD,cAAQ;AAAA,QACJ;AAAA,QACA;AAAA,MAChB,CAAa;AAAA,IACJ;AACD,WAAO,GAAG,SAAS,OAAO;AAC1B,WAAO,GAAG,SAAS,OAAO;AAC1B,WAAO,GAAG,OAAO,KAAK;AACtB;EACR,CAAK;AACL;AACeD,qBAAA,UAAA,UAAG;","x_google_ignoreList":[0]}