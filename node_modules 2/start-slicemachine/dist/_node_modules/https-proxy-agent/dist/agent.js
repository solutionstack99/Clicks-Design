import { commonjsGlobal } from "../../../_virtual/_commonjsHelpers.js";
import { __exports as agent } from "../../../_virtual/agent.js";
import require$$0 from "net";
import require$$1 from "tls";
import require$$2__default from "url";
import require$$3 from "assert";
import { b as browserExports } from "../../debug/src/browser.js";
import { s as src } from "../../agent-base/dist/src/index.js";
import "./parse-proxy-response.js";
import { __exports as parseProxyResponse } from "../../../_virtual/parse-proxy-response.js";
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(agent, "__esModule", { value: true });
const net_1 = __importDefault(require$$0);
const tls_1 = __importDefault(require$$1);
const url_1 = __importDefault(require$$2__default);
const assert_1 = __importDefault(require$$3);
const debug_1 = __importDefault(browserExports);
const agent_base_1 = src;
const parse_proxy_response_1 = __importDefault(parseProxyResponse);
const debug = debug_1.default("https-proxy-agent:agent");
class HttpsProxyAgent extends agent_base_1.Agent {
  constructor(_opts) {
    let opts;
    if (typeof _opts === "string") {
      opts = url_1.default.parse(_opts);
    } else {
      opts = _opts;
    }
    if (!opts) {
      throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
    }
    debug("creating new HttpsProxyAgent instance: %o", opts);
    super(opts);
    const proxy = Object.assign({}, opts);
    this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
    proxy.host = proxy.hostname || proxy.host;
    if (typeof proxy.port === "string") {
      proxy.port = parseInt(proxy.port, 10);
    }
    if (!proxy.port && proxy.host) {
      proxy.port = this.secureProxy ? 443 : 80;
    }
    if (this.secureProxy && !("ALPNProtocols" in proxy)) {
      proxy.ALPNProtocols = ["http 1.1"];
    }
    if (proxy.host && proxy.path) {
      delete proxy.path;
      delete proxy.pathname;
    }
    this.proxy = proxy;
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   *
   * @api protected
   */
  callback(req, opts) {
    return __awaiter(this, void 0, void 0, function* () {
      const { proxy, secureProxy } = this;
      let socket;
      if (secureProxy) {
        debug("Creating `tls.Socket`: %o", proxy);
        socket = tls_1.default.connect(proxy);
      } else {
        debug("Creating `net.Socket`: %o", proxy);
        socket = net_1.default.connect(proxy);
      }
      const headers = Object.assign({}, proxy.headers);
      const hostname = `${opts.host}:${opts.port}`;
      let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
      if (proxy.auth) {
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
      }
      let { host, port, secureEndpoint } = opts;
      if (!isDefaultPort(port, secureEndpoint)) {
        host += `:${port}`;
      }
      headers.Host = host;
      headers.Connection = "close";
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = parse_proxy_response_1.default(socket);
      socket.write(`${payload}\r
`);
      const { statusCode, buffered } = yield proxyResponsePromise;
      if (statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          const servername = opts.servername || opts.host;
          return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
            socket,
            servername
          }));
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net_1.default.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("replaying proxy buffer for failed request");
        assert_1.default(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    });
  }
}
agent.default = HttpsProxyAgent;
function resume(socket) {
  socket.resume();
}
function isDefaultPort(port, secure) {
  return Boolean(!secure && port === 80 || secure && port === 443);
}
function isHTTPS(protocol) {
  return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
//# sourceMappingURL=agent.js.map
