{"version":3,"file":"lru.js","sources":["../../../../../node_modules/lru_map/lru.js"],"sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nfunction LRUMap(limit, entries) {\n  if (typeof limit !== 'number') {\n    // called as (entries)\n    entries = limit;\n    limit = 0;\n  }\n\n  this.size = 0;\n  this.limit = limit;\n  this.oldest = this.newest = undefined;\n  this._keymap = new Map();\n\n  if (entries) {\n    this.assign(entries);\n    if (limit < 1) {\n      this.limit = this.size;\n    }\n  }\n}\n\nexports.LRUMap = LRUMap;\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nLRUMap.prototype._markEntryAsUsed = function(entry) {\n  if (entry === this.newest) {\n    // Already the most recenlty used entry, so no need to update the list\n    return;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry[NEWER]) {\n    if (entry === this.oldest) {\n      this.oldest = entry[NEWER];\n    }\n    entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n  }\n  if (entry[OLDER]) {\n    entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n  }\n  entry[NEWER] = undefined; // D --x\n  entry[OLDER] = this.newest; // D. --> E\n  if (this.newest) {\n    this.newest[NEWER] = entry; // E. <-- D\n  }\n  this.newest = entry;\n};\n\nLRUMap.prototype.assign = function(entries) {\n  let entry, limit = this.limit || Number.MAX_VALUE;\n  this._keymap.clear();\n  let it = entries[Symbol.iterator]();\n  for (let itv = it.next(); !itv.done; itv = it.next()) {\n    let e = new Entry(itv.value[0], itv.value[1]);\n    this._keymap.set(e.key, e);\n    if (!entry) {\n      this.oldest = e;\n    } else {\n      entry[NEWER] = e;\n      e[OLDER] = entry;\n    }\n    entry = e;\n    if (limit-- == 0) {\n      throw new Error('overflow');\n    }\n  }\n  this.newest = entry;\n  this.size = this._keymap.size;\n};\n\nLRUMap.prototype.get = function(key) {\n  // First, find our cache entry\n  var entry = this._keymap.get(key);\n  if (!entry) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  this._markEntryAsUsed(entry);\n  return entry.value;\n};\n\nLRUMap.prototype.set = function(key, value) {\n  var entry = this._keymap.get(key);\n\n  if (entry) {\n    // update existing\n    entry.value = value;\n    this._markEntryAsUsed(entry);\n    return this;\n  }\n\n  // new entry\n  this._keymap.set(key, (entry = new Entry(key, value)));\n\n  if (this.newest) {\n    // link previous tail to the new tail (entry)\n    this.newest[NEWER] = entry;\n    entry[OLDER] = this.newest;\n  } else {\n    // we're first in -- yay\n    this.oldest = entry;\n  }\n\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.newest = entry;\n  ++this.size;\n  if (this.size > this.limit) {\n    // we hit the limit -- remove the head\n    this.shift();\n  }\n\n  return this;\n};\n\nLRUMap.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.oldest;\n  if (entry) {\n    if (this.oldest[NEWER]) {\n      // advance the list\n      this.oldest = this.oldest[NEWER];\n      this.oldest[OLDER] = undefined;\n    } else {\n      // the cache is exhausted\n      this.oldest = undefined;\n      this.newest = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry[NEWER] = entry[OLDER] = undefined;\n    this._keymap.delete(entry.key);\n    --this.size;\n    return [entry.key, entry.value];\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\nLRUMap.prototype.find = function(key) {\n  let e = this._keymap.get(key);\n  return e ? e.value : undefined;\n};\n\nLRUMap.prototype.has = function(key) {\n  return this._keymap.has(key);\n};\n\nLRUMap.prototype['delete'] = function(key) {\n  var entry = this._keymap.get(key);\n  if (!entry) return;\n  this._keymap.delete(entry.key);\n  if (entry[NEWER] && entry[OLDER]) {\n    // relink the older entry with the newer entry\n    entry[OLDER][NEWER] = entry[NEWER];\n    entry[NEWER][OLDER] = entry[OLDER];\n  } else if (entry[NEWER]) {\n    // remove the link to us\n    entry[NEWER][OLDER] = undefined;\n    // link the newer entry to head\n    this.oldest = entry[NEWER];\n  } else if (entry[OLDER]) {\n    // remove the link to us\n    entry[OLDER][NEWER] = undefined;\n    // link the newer entry to head\n    this.newest = entry[OLDER];\n  } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n    this.oldest = this.newest = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\nLRUMap.prototype.clear = function() {\n  // Not clearing links should be safe, as we don't expose live links to user\n  this.oldest = this.newest = undefined;\n  this.size = 0;\n  this._keymap.clear();\n};\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nLRUMap.prototype.keys = function() {\n  return new KeyIterator(this.oldest);\n};\n\nLRUMap.prototype.values = function() {\n  return new ValueIterator(this.oldest);\n};\n\nLRUMap.prototype.entries = function() {\n  return this;\n};\n\nLRUMap.prototype[Symbol.iterator] = function() {\n  return new EntryIterator(this.oldest);\n};\n\nLRUMap.prototype.forEach = function(fun, thisObj) {\n  if (typeof thisObj !== 'object') {\n    thisObj = this;\n  }\n  let entry = this.oldest;\n  while (entry) {\n    fun.call(thisObj, entry.value, entry.key, this);\n    entry = entry[NEWER];\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUMap.prototype.toJSON = function() {\n  var s = new Array(this.size), i = 0, entry = this.oldest;\n  while (entry) {\n    s[i++] = { key: entry.key, value: entry.value };\n    entry = entry[NEWER];\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUMap.prototype.toString = function() {\n  var s = '', entry = this.oldest;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry[NEWER];\n    if (entry) {\n      s += ' < ';\n    }\n  }\n  return s;\n};\n\n});\n"],"names":["this","exports"],"mappings":"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","x_google_ignoreList":[0]}