{"version":3,"file":"server-runtime-client.cjs","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/server-runtime-client.js"],"sourcesContent":["import { resolvedSyncPromise, eventFromUnknownInput, eventFromMessage, logger, uuid4 } from '@sentry/utils';\nimport { BaseClient } from './baseclient.js';\nimport { createCheckInEnvelope } from './checkin.js';\nimport { getCurrentHub } from './hub.js';\nimport { SessionFlusher } from './sessionflusher.js';\nimport { addTracingExtensions } from './tracing/hubextensions.js';\nimport { getDynamicSamplingContextFromClient } from './tracing/dynamicSamplingContext.js';\nimport './tracing/spanstatus.js';\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient\n\n extends BaseClient {\n\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    // Server clients always support tracing\n    addTracingExtensions();\n\n    super(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    return resolvedSyncPromise(eventFromUnknownInput(getCurrentHub, this._options.stackParser, exception, hint));\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n    // eslint-disable-next-line deprecation/deprecation\n    level = 'info',\n    hint,\n  ) {\n    return resolvedSyncPromise(\n      eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n   captureException(exception, hint, scope) {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const requestSession = scope.getRequestSession();\n\n      // Necessary checks to ensure this is code block is executed only within a request\n      // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage\n      if (requestSession && requestSession.status === 'ok') {\n        requestSession.status = 'errored';\n      }\n    }\n\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const eventType = event.type || 'exception';\n      const isException =\n        eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;\n\n      // If the event is of type Exception, then a request session should be captured\n      if (isException) {\n        const requestSession = scope.getRequestSession();\n\n        // Ensure that this is happening within the bounds of a request, and make sure not to override\n        // Session Status if Errored / Crashed\n        if (requestSession && requestSession.status === 'ok') {\n          requestSession.status = 'errored';\n        }\n      }\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   *\n   * @inheritdoc\n   */\n   close(timeout) {\n    if (this._sessionFlusher) {\n      this._sessionFlusher.close();\n    }\n    return super.close(timeout);\n  }\n\n  /** Method that initialises an instance of SessionFlusher on Client */\n   initSessionFlusher() {\n    const { release, environment } = this._options;\n    if (!release) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');\n    } else {\n      this._sessionFlusher = new SessionFlusher(this, {\n        release,\n        environment,\n      });\n    }\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n   captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = checkIn.status !== 'in_progress' && checkIn.checkInId ? checkIn.checkInId : uuid4();\n    if (!this._isEnabled()) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture checkin.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if (checkIn.status !== 'in_progress') {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = this._getTraceInfoFromScope(scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = createCheckInEnvelope(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.info('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n    void this._sendEnvelope(envelope);\n    return id;\n  }\n\n  /**\n   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment\n   * appropriate session aggregates bucket\n   */\n   _captureRequestSession() {\n    if (!this._sessionFlusher) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');\n    } else {\n      this._sessionFlusher.incrementSessionStatusCount();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(event, hint, scope) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: (event.contexts || {}).runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, scope);\n  }\n\n  /** Extract trace information from scope */\n   _getTraceInfoFromScope(\n    scope,\n  ) {\n    if (!scope) {\n      return [undefined, undefined];\n    }\n\n    const span = scope.getSpan();\n    if (span) {\n      const samplingContext = span.transaction ? span.transaction.getDynamicSamplingContext() : undefined;\n      return [samplingContext, span.getTraceContext()];\n    }\n\n    const { traceId, spanId, parentSpanId, dsc } = scope.getPropagationContext();\n    const traceContext = {\n      trace_id: traceId,\n      span_id: spanId,\n      parent_span_id: parentSpanId,\n    };\n    if (dsc) {\n      return [dsc, traceContext];\n    }\n\n    return [getDynamicSamplingContextFromClient(traceId, this, scope), traceContext];\n  }\n}\n\nexport { ServerRuntimeClient };\n//# sourceMappingURL=server-runtime-client.js.map\n"],"names":["BaseClient","addTracingExtensions","resolvedSyncPromise","eventFromUnknownInput","getCurrentHub","eventFromMessage","logger","SessionFlusher","uuid4","dynamicSamplingContext","createCheckInEnvelope","getDynamicSamplingContextFromClient"],"mappings":"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","x_google_ignoreList":[0]}