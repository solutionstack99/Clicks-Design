{"version":3,"file":"instrument.js","sources":["../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/utils/esm/instrument.js"],"sourcesContent":["import { isString } from './is.js';\nimport { logger, CONSOLE_LEVELS, originalConsoleMethods } from './logger.js';\nimport { fill } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\nimport { supportsNativeFetch } from './supports.js';\nimport { getGlobalObject, GLOBAL_OBJ } from './worldwide.js';\nimport { supportsHistory } from './vendor/supportsHistory.js';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject();\n\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v2__';\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers = {};\nconst instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(callback);\n  instrument(type);\n}\n\n/**\n * Reset all instrumentation handlers.\n * This can be used by tests to ensure we have a clean slate of instrumentation handlers.\n */\nfunction resetInstrumentationHandlers() {\n  Object.keys(handlers).forEach(key => {\n    handlers[key ] = undefined;\n  });\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in GLOBAL_OBJ)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in GLOBAL_OBJ.console)) {\n      return;\n    }\n\n    fill(GLOBAL_OBJ.console, level, function (originalConsoleMethod) {\n      originalConsoleMethods[level] = originalConsoleMethod;\n\n      return function (...args) {\n        triggerHandlers('console', { args, level });\n\n        const log = originalConsoleMethods[level];\n        log && log.apply(GLOBAL_OBJ.console, args);\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(GLOBAL_OBJ, 'fetch', function (originalFetch) {\n    return function (...args) {\n      const { method, url } = parseFetchArgs(args);\n\n      const handlerData = {\n        args,\n        fetchData: {\n          method,\n          url,\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(GLOBAL_OBJ, args).then(\n        (response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\nfunction hasProp(obj, prop) {\n  return !!obj && typeof obj === 'object' && !!(obj )[prop];\n}\n\nfunction getUrlFromResource(resource) {\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  if (!resource) {\n    return '';\n  }\n\n  if (hasProp(resource, 'url')) {\n    return resource.url;\n  }\n\n  if (resource.toString) {\n    return resource.toString();\n  }\n\n  return '';\n}\n\n/**\n * Parses the fetch arguments to find the used Http method and the url of the request\n */\nfunction parseFetchArgs(fetchArgs) {\n  if (fetchArgs.length === 0) {\n    return { method: 'GET', url: '' };\n  }\n\n  if (fetchArgs.length === 2) {\n    const [url, options] = fetchArgs ;\n\n    return {\n      url: getUrlFromResource(url),\n      method: hasProp(options, 'method') ? String(options.method).toUpperCase() : 'GET',\n    };\n  }\n\n  const arg = fetchArgs[0];\n  return {\n    url: getUrlFromResource(arg ),\n    method: hasProp(arg, 'method') ? String(arg.method).toUpperCase() : 'GET',\n  };\n}\n\n/** JSDoc */\nfunction instrumentXHR() {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (!(WINDOW ).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function ( ...args) {\n      const url = args[1];\n      const xhrInfo = (this[SENTRY_XHR_DATA_KEY] = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n        request_headers: {},\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args: args ,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: this,\n          } );\n        }\n      };\n\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original) {\n          return function ( ...readyStateArgs) {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original) {\n        return function ( ...setRequestHeaderArgs) {\n          const [header, value] = setRequestHeaderArgs ;\n\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n\n      return originalOpen.apply(this, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend) {\n    return function ( ...args) {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      if (sentryXhrData && args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function ( ...args) {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID;\nlet lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target ;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler, globalListener = false) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (WINDOW )[target] && (WINDOW )[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (\n\n        type,\n        listener,\n        options,\n      ) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this ;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function (\n\n          type,\n          listener,\n          options,\n        ) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this ;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = WINDOW.onerror;\n\n  WINDOW.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n\n  WINDOW.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\n\nlet _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n\n  WINDOW.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n\n  WINDOW.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\n\nexport { SENTRY_XHR_DATA_KEY, addInstrumentationHandler, instrumentDOM, instrumentXHR, parseFetchArgs, resetInstrumentationHandlers };\n//# sourceMappingURL=instrument.js.map\n"],"names":["xhrInfo","handlers"],"mappings":"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","x_google_ignoreList":[0]}