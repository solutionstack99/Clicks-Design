{"version":3,"file":"errors.cjs","sources":["../../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/tracing/errors.js"],"sourcesContent":["import { addInstrumentationHandler, logger } from '@sentry/utils';\nimport { getActiveTransaction } from './utils.js';\n\nlet errorsInstrumented = false;\n\n/**\n * Configures global error listeners\n */\nfunction registerErrorInstrumentation() {\n  if (errorsInstrumented) {\n    return;\n  }\n\n  errorsInstrumented = true;\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback() {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status = 'internal_error';\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = 'sentry_tracingErrorCallback';\n\nexport { registerErrorInstrumentation };\n//# sourceMappingURL=errors.js.map\n"],"names":["addInstrumentationHandler","getActiveTransaction","logger"],"mappings":";;;;;AAGA,IAAI,qBAAqB;AAKzB,SAAS,+BAA+B;AACtC,MAAI,oBAAoB;AACtB;AAAA,EACD;AAED,uBAAqB;AACrBA,uCAA0B,SAAS,aAAa;AAChDA,uCAA0B,sBAAsB,aAAa;AAC/D;AAKA,SAAS,gBAAgB;AACvB,QAAM,oBAAoBC,MAAAA;AAC1B,MAAI,mBAAmB;AACrB,UAAM,SAAS;AACf,KAAC,OAAO,qBAAqB,eAAe,qBAAqBC,OAAM,OAAC,IAAI,0BAA0B,gCAAgC;AACtI,sBAAkB,UAAU,MAAM;AAAA,EACnC;AACH;AAIA,cAAc,MAAM;;","x_google_ignoreList":[0]}