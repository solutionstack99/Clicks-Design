{"version":3,"file":"hubextensions.cjs","sources":["../../../../../../../../../../../node_modules/@sentry/node/node_modules/@sentry/core/esm/tracing/hubextensions.js"],"sourcesContent":["import { logger, isNaN } from '@sentry/utils';\nimport { getMainCarrier } from '../hub.js';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled.js';\nimport { registerErrorInstrumentation } from './errors.js';\nimport { IdleTransaction } from './idletransaction.js';\nimport { Transaction } from './transaction.js';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders() {\n  const scope = this.getScope();\n  const span = scope.getSpan();\n\n  return span\n    ? {\n        'sentry-trace': span.toTraceparent(),\n      }\n    : {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample(\n  transaction,\n  options,\n  samplingContext,\n) {\n  // nothing to do if tracing is not enabled\n  if (!hasTracingEnabled(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      sampleRate: Number(transaction.sampled),\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` nor `enableTracing` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  } else {\n    // When `enableTracing === true`, we use a sample rate of 100%\n    sampleRate = 1;\n    transaction.setMetadata({\n      sampleRate,\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate );\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n\n  transactionContext,\n  customSamplingContext,\n) {\n  const client = this.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  const configInstrumenter = options.instrumenter || 'sentry';\n  const transactionInstrumenter = transactionContext.instrumenter || 'sentry';\n\n  if (configInstrumenter !== transactionInstrumenter) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.error(\n        `A transaction was started with instrumenter=\\`${transactionInstrumenter}\\`, but the SDK is configured with the \\`${configInstrumenter}\\` instrumenter.\nThe transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`,\n      );\n\n    transactionContext.sampled = false;\n  }\n\n  let transaction = new Transaction(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  if (client && client.emit) {\n    client.emit('startTransaction', transaction);\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nfunction startIdleTransaction(\n  hub,\n  transactionContext,\n  idleTimeout,\n  finalTimeout,\n  onScope,\n  customSamplingContext,\n  heartbeatInterval,\n) {\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, finalTimeout, heartbeatInterval, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  if (client && client.emit) {\n    client.emit('startTransaction', transaction);\n  }\n  return transaction;\n}\n\n/**\n * Adds tracing extensions to the global hub.\n */\nfunction addTracingExtensions() {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n\n  registerErrorInstrumentation();\n}\n\nexport { addTracingExtensions, startIdleTransaction };\n//# sourceMappingURL=hubextensions.js.map\n"],"names":["transaction","hasTracingEnabled","logger","isNaN","Transaction","getMainCarrier","registerErrorInstrumentation"],"mappings":"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","x_google_ignoreList":[0]}