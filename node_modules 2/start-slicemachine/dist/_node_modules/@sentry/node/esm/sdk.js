import { setNodeAsyncContextStrategy } from "./async/index.js";
import { NodeClient } from "./client.js";
import { Console } from "./integrations/console.js";
import { Http } from "./integrations/http.js";
import { OnUncaughtException } from "./integrations/onuncaughtexception.js";
import { OnUnhandledRejection } from "./integrations/onunhandledrejection.js";
import { LinkedErrors } from "./integrations/linkederrors.js";
import { Modules } from "./integrations/modules.js";
import { ContextLines } from "./integrations/contextlines.js";
import { Context } from "./integrations/context.js";
import { RequestData } from "./integrations/requestdata.js";
import { LocalVariables } from "./integrations/localvariables.js";
import { Undici } from "./integrations/undici/index.js";
import { getModuleFromFilename } from "./module.js";
import { makeNodeTransport } from "./transports/http.js";
import { getMainCarrier, getCurrentHub } from './../_node_modules/@sentry/core/esm/hub.js';
import { _optionalChain } from './../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { stackParserFromStackParserOptions, createStackParser, nodeStackLineParser } from './../_node_modules/@sentry/utils/esm/stacktrace.js';
import { getIntegrationsToSetup } from './../_node_modules/@sentry/core/esm/integration.js';
import { initAndBind } from './../_node_modules/@sentry/core/esm/sdk.js';
import { GLOBAL_OBJ } from './../_node_modules/@sentry/utils/esm/worldwide.js';
import { tracingContextFromHeaders } from './../_node_modules/@sentry/utils/esm/tracing.js';
import { InboundFilters } from './../_node_modules/@sentry/core/esm/integrations/inboundfilters.js';
import { FunctionToString } from './../_node_modules/@sentry/core/esm/integrations/functiontostring.js';
const defaultIntegrations = [
  // Common
  new InboundFilters(),
  new FunctionToString(),
  // Native Wrappers
  new Console(),
  new Http(),
  new Undici(),
  // Global Handlers
  new OnUncaughtException(),
  new OnUnhandledRejection(),
  // Event Info
  new ContextLines(),
  new LocalVariables(),
  new Context(),
  new Modules(),
  new RequestData(),
  // Misc
  new LinkedErrors()
];
function init(options = {}) {
  const carrier = getMainCarrier();
  setNodeAsyncContextStrategy();
  const autoloadedIntegrations = _optionalChain([carrier, "access", (_) => _.__SENTRY__, "optionalAccess", (_2) => _2.integrations]) || [];
  options.defaultIntegrations = options.defaultIntegrations === false ? [] : [
    ...Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations,
    ...autoloadedIntegrations
  ];
  if (options.dsn === void 0 && process.env.SENTRY_DSN) {
    options.dsn = process.env.SENTRY_DSN;
  }
  const sentryTracesSampleRate = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (options.tracesSampleRate === void 0 && sentryTracesSampleRate) {
    const tracesSampleRate = parseFloat(sentryTracesSampleRate);
    if (isFinite(tracesSampleRate)) {
      options.tracesSampleRate = tracesSampleRate;
    }
  }
  if (options.release === void 0) {
    const detectedRelease = getSentryRelease();
    if (detectedRelease !== void 0) {
      options.release = detectedRelease;
    } else {
      options.autoSessionTracking = false;
    }
  }
  if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
    options.environment = process.env.SENTRY_ENVIRONMENT;
  }
  if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
    options.autoSessionTracking = true;
  }
  if (options.instrumenter === void 0) {
    options.instrumenter = "sentry";
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || makeNodeTransport
  };
  initAndBind(options.clientClass || NodeClient, clientOptions);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
  updateScopeFromEnvVariables();
}
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE && GLOBAL_OBJ.SENTRY_RELEASE.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env.COMMIT_REF || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || // Zeit (now known as Vercel)
    process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || fallback
  );
}
const defaultStackParser = createStackParser(nodeStackLineParser(getModuleFromFilename));
function startSessionTracking() {
  const hub = getCurrentHub();
  hub.startSession();
  process.on("beforeExit", () => {
    const session = hub.getScope().getSession();
    const terminalStates = ["exited", "crashed"];
    if (session && !terminalStates.includes(session.status))
      hub.endSession();
  });
}
function updateScopeFromEnvVariables() {
  const sentryUseEnvironment = (process.env.SENTRY_USE_ENVIRONMENT || "").toLowerCase();
  if (!["false", "n", "no", "off", "0"].includes(sentryUseEnvironment)) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const { propagationContext } = tracingContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentHub().getScope().setPropagationContext(propagationContext);
  }
}
export {
  defaultIntegrations,
  defaultStackParser,
  getSentryRelease,
  init
};
//# sourceMappingURL=sdk.js.map
