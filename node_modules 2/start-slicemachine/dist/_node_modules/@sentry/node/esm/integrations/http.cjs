"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
require("../../../../lru_map/lru.cjs");
const nodeVersion = require("../nodeVersion.cjs");
const http = require("./utils/http.cjs");
const _optionalChain = require('./../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const logger = require('./../../_node_modules/@sentry/utils/esm/logger.cjs');
const object = require('./../../_node_modules/@sentry/utils/esm/object.cjs');
const lru = require("../../../../../_virtual/lru.cjs");
const hub = require('./../../_node_modules/@sentry/core/esm/hub.cjs');
const tracing = require('./../../_node_modules/@sentry/utils/esm/tracing.cjs');
const dynamicSamplingContext = require('./../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.cjs');
const baggage = require('./../../_node_modules/@sentry/utils/esm/baggage.cjs');
const string = require('./../../_node_modules/@sentry/utils/esm/string.cjs');
class Http {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Http";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = Http.id;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
    this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
    if (!this._breadcrumbs && !this._tracing) {
      return;
    }
    const clientOptions = _optionalChain._optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    if (clientOptions && clientOptions.instrumenter !== "sentry") {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.log("HTTP Integration is skipped because of instrumenter configuration.");
      return;
    }
    const shouldCreateSpanForRequest = (
      // eslint-disable-next-line deprecation/deprecation
      _optionalChain._optionalChain([this, "access", (_6) => _6._tracing, "optionalAccess", (_7) => _7.shouldCreateSpanForRequest]) || _optionalChain._optionalChain([clientOptions, "optionalAccess", (_8) => _8.shouldCreateSpanForRequest])
    );
    const tracePropagationTargets = _optionalChain._optionalChain([clientOptions, "optionalAccess", (_9) => _9.tracePropagationTargets]) || _optionalChain._optionalChain([this, "access", (_10) => _10._tracing, "optionalAccess", (_11) => _11.tracePropagationTargets]);
    const httpModule = require("http");
    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(
      httpModule,
      this._breadcrumbs,
      shouldCreateSpanForRequest,
      tracePropagationTargets
    );
    object.fill(httpModule, "get", wrappedHttpHandlerMaker);
    object.fill(httpModule, "request", wrappedHttpHandlerMaker);
    if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major > 8) {
      const httpsModule = require("https");
      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
        httpsModule,
        this._breadcrumbs,
        shouldCreateSpanForRequest,
        tracePropagationTargets
      );
      object.fill(httpsModule, "get", wrappedHttpsHandlerMaker);
      object.fill(httpsModule, "request", wrappedHttpsHandlerMaker);
    }
  }
}
Http.__initStatic();
function _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
  const createSpanUrlMap = new lru.__exports.LRUMap(100);
  const headersUrlMap = new lru.__exports.LRUMap(100);
  const shouldCreateSpan = (url) => {
    if (shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = shouldCreateSpanForRequest(url);
    createSpanUrlMap.set(url, decision);
    return decision;
  };
  const shouldAttachTraceData = (url) => {
    if (tracePropagationTargets === void 0) {
      return true;
    }
    const cachedDecision = headersUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = string.stringMatchesSomePattern(url, tracePropagationTargets);
    headersUrlMap.set(url, decision);
    return decision;
  };
  function addRequestBreadcrumb(event, requestSpanData, req, res) {
    if (!hub.getCurrentHub().getIntegration(Http)) {
      return;
    }
    hub.getCurrentHub().addBreadcrumb(
      {
        category: "http",
        data: {
          status_code: res && res.statusCode,
          ...requestSpanData
        },
        type: "http"
      },
      {
        event,
        request: req,
        response: res
      }
    );
  }
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod(...args) {
      const requestArgs = http.normalizeRequestArgs(httpModule, args);
      const requestOptions = requestArgs[0];
      const rawRequestUrl = http.extractRawUrl(requestOptions);
      const requestUrl = http.extractUrl(requestOptions);
      if (http.isSentryRequest(requestUrl)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }
      const hub$1 = hub.getCurrentHub();
      const scope = hub$1.getScope();
      const parentSpan = scope.getSpan();
      const data = getRequestSpanData(requestUrl, requestOptions);
      const requestSpan = shouldCreateSpan(rawRequestUrl) ? _optionalChain._optionalChain([parentSpan, "optionalAccess", (_12) => _12.startChild, "call", (_13) => _13({
        op: "http.client",
        origin: "auto.http.node.http",
        description: `${data["http.method"]} ${data.url}`,
        data
      })]) : void 0;
      if (shouldAttachTraceData(rawRequestUrl)) {
        if (requestSpan) {
          const sentryTraceHeader = requestSpan.toTraceparent();
          const dynamicSamplingContext2 = _optionalChain._optionalChain([requestSpan, "optionalAccess", (_14) => _14.transaction, "optionalAccess", (_15) => _15.getDynamicSamplingContext, "call", (_16) => _16()]);
          addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext2);
        } else {
          const client = hub$1.getClient();
          const { traceId, sampled, dsc } = scope.getPropagationContext();
          const sentryTraceHeader = tracing.generateSentryTraceHeader(traceId, void 0, sampled);
          const dynamicSamplingContext$1 = dsc || (client ? dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, client, scope) : void 0);
          addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext$1);
        }
      } else {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.log(
          `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
        );
      }
      return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("response", data, req, res);
        }
        if (requestSpan) {
          if (res.statusCode) {
            requestSpan.setHttpStatus(res.statusCode);
          }
          requestSpan.description = http.cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      }).once("error", function() {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("error", data, req);
        }
        if (requestSpan) {
          requestSpan.setHttpStatus(500);
          requestSpan.description = http.cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      });
    };
  };
}
function addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext2) {
  const headers = requestOptions.headers || {};
  if (headers["sentry-trace"]) {
    return;
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
  const sentryBaggage = baggage.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext2);
  const sentryBaggageHeader = sentryBaggage && sentryBaggage.length > 0 ? normalizeBaggageHeader(requestOptions, sentryBaggage) : void 0;
  requestOptions.headers = {
    ...requestOptions.headers,
    "sentry-trace": sentryTraceHeader,
    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined
    ...sentryBaggageHeader && { baggage: sentryBaggageHeader }
  };
}
function getRequestSpanData(requestUrl, requestOptions) {
  const method = requestOptions.method || "GET";
  const data = {
    url: requestUrl,
    "http.method": method
  };
  if (requestOptions.hash) {
    data["http.fragment"] = requestOptions.hash.substring(1);
  }
  if (requestOptions.search) {
    data["http.query"] = requestOptions.search.substring(1);
  }
  return data;
}
function normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {
  if (!requestOptions.headers || !requestOptions.headers.baggage) {
    return sentryBaggageHeader;
  } else if (!sentryBaggageHeader) {
    return requestOptions.headers.baggage;
  } else if (Array.isArray(requestOptions.headers.baggage)) {
    return [...requestOptions.headers.baggage, sentryBaggageHeader];
  }
  return [requestOptions.headers.baggage, sentryBaggageHeader];
}
exports.Http = Http;
//# sourceMappingURL=http.cjs.map
