import { readFile } from "fs";
import "../../../../lru_map/lru.js";
import { __exports as lru } from "../../../../../_virtual/lru.js";
import { _optionalChain } from './../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { addContextToFrame } from './../../_node_modules/@sentry/utils/esm/misc.js';
const FILE_CONTENT_CACHE = new lru.LRUMap(100);
const DEFAULT_LINES_OF_CONTEXT = 7;
function readTextFileAsync(path) {
  return new Promise((resolve, reject) => {
    readFile(path, "utf8", (err, data) => {
      if (err)
        reject(err);
      else
        resolve(data);
    });
  });
}
class ContextLines {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "ContextLines";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = ContextLines.id;
  }
  constructor(_options = {}) {
    this._options = _options;
    ContextLines.prototype.__init.call(this);
  }
  /** Get's the number of context lines to add */
  get _contextLines() {
    return this._options.frameContextLines !== void 0 ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
  }
  /**
   * @inheritDoc
   */
  setupOnce(addGlobalEventProcessor, getCurrentHub) {
    addGlobalEventProcessor((event) => {
      const self = getCurrentHub().getIntegration(ContextLines);
      if (!self) {
        return event;
      }
      return this.addSourceContext(event);
    });
  }
  /** Processes an event and adds context lines */
  async addSourceContext(event) {
    const enqueuedReadSourceFileTasks = {};
    const readSourceFileTasks = [];
    if (this._contextLines > 0 && _optionalChain([event, "access", (_2) => _2.exception, "optionalAccess", (_3) => _3.values])) {
      for (const exception of event.exception.values) {
        if (!_optionalChain([exception, "access", (_4) => _4.stacktrace, "optionalAccess", (_5) => _5.frames])) {
          continue;
        }
        for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
          const frame = exception.stacktrace.frames[i];
          if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
            readSourceFileTasks.push(_readSourceFile(frame.filename));
            enqueuedReadSourceFileTasks[frame.filename] = 1;
          }
        }
      }
    }
    if (readSourceFileTasks.length > 0) {
      await Promise.all(readSourceFileTasks);
    }
    if (this._contextLines > 0 && _optionalChain([event, "access", (_6) => _6.exception, "optionalAccess", (_7) => _7.values])) {
      for (const exception of event.exception.values) {
        if (exception.stacktrace && exception.stacktrace.frames) {
          await this.addSourceContextToFrames(exception.stacktrace.frames);
        }
      }
    }
    return event;
  }
  /** Adds context lines to frames */
  addSourceContextToFrames(frames) {
    for (const frame of frames) {
      if (frame.filename && frame.context_line === void 0) {
        const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);
        if (sourceFileLines) {
          try {
            addContextToFrame(sourceFileLines, frame, this._contextLines);
          } catch (e) {
          }
        }
      }
    }
  }
}
ContextLines.__initStatic();
async function _readSourceFile(filename) {
  const cachedFile = FILE_CONTENT_CACHE.get(filename);
  if (cachedFile === null) {
    return null;
  }
  if (cachedFile !== void 0) {
    return cachedFile;
  }
  let content = null;
  try {
    const rawFileContents = await readTextFileAsync(filename);
    content = rawFileContents.split("\n");
  } catch (_) {
  }
  FILE_CONTENT_CACHE.set(filename, content);
  return content;
}
export {
  ContextLines
};
//# sourceMappingURL=contextlines.js.map
