"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
require("../../../../../lru_map/lru.cjs");
const nodeVersion = require("../../nodeVersion.cjs");
const http = require("../utils/http.cjs");
const lru = require("../../../../../../_virtual/lru.cjs");
const node = require('./../../../_node_modules/@sentry/utils/esm/node.cjs');
const hub = require('./../../../_node_modules/@sentry/core/esm/hub.cjs');
const _optionalChain = require('./../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.cjs');
const baggage = require('./../../../_node_modules/@sentry/utils/esm/baggage.cjs');
const tracing = require('./../../../_node_modules/@sentry/utils/esm/tracing.cjs');
const dynamicSamplingContext = require('./../../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.cjs');
const url = require('./../../../_node_modules/@sentry/utils/esm/url.cjs');
const string = require('./../../../_node_modules/@sentry/utils/esm/string.cjs');
exports.ChannelName = void 0;
(function(ChannelName) {
  const RequestCreate = "undici:request:create";
  ChannelName["RequestCreate"] = RequestCreate;
  const RequestEnd = "undici:request:headers";
  ChannelName["RequestEnd"] = RequestEnd;
  const RequestError = "undici:request:error";
  ChannelName["RequestError"] = RequestError;
})(exports.ChannelName || (exports.ChannelName = {}));
class Undici {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Undici";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = Undici.id;
  }
  __init2() {
    this._createSpanUrlMap = new lru.__exports.LRUMap(100);
  }
  __init3() {
    this._headersUrlMap = new lru.__exports.LRUMap(100);
  }
  constructor(_options = {}) {
    Undici.prototype.__init.call(this);
    Undici.prototype.__init2.call(this);
    Undici.prototype.__init3.call(this);
    Undici.prototype.__init4.call(this);
    Undici.prototype.__init5.call(this);
    Undici.prototype.__init6.call(this);
    this._options = {
      breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
      shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
    };
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor) {
    if (nodeVersion.NODE_VERSION.major && nodeVersion.NODE_VERSION.major < 16) {
      return;
    }
    let ds;
    try {
      ds = node.dynamicRequire(module, "diagnostics_channel");
    } catch (e) {
    }
    if (!ds || !ds.subscribe) {
      return;
    }
    ds.subscribe(exports.ChannelName.RequestCreate, this._onRequestCreate);
    ds.subscribe(exports.ChannelName.RequestEnd, this._onRequestEnd);
    ds.subscribe(exports.ChannelName.RequestError, this._onRequestError);
  }
  /** Helper that wraps shouldCreateSpanForRequest option */
  _shouldCreateSpan(url2) {
    if (this._options.shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = this._createSpanUrlMap.get(url2);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = this._options.shouldCreateSpanForRequest(url2);
    this._createSpanUrlMap.set(url2, decision);
    return decision;
  }
  __init4() {
    this._onRequestCreate = (message) => {
      const hub$1 = hub.getCurrentHub();
      if (!hub$1.getIntegration(Undici)) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (http.isSentryRequest(stringUrl) || request.__sentry_span__ !== void 0) {
        return;
      }
      const client = hub$1.getClient();
      if (!client) {
        return;
      }
      const clientOptions = client.getOptions();
      const scope = hub$1.getScope();
      const parentSpan = scope.getSpan();
      const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : void 0;
      if (span) {
        request.__sentry_span__ = span;
      }
      const shouldAttachTraceData = (url2) => {
        if (clientOptions.tracePropagationTargets === void 0) {
          return true;
        }
        const cachedDecision = this._headersUrlMap.get(url2);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = string.stringMatchesSomePattern(url2, clientOptions.tracePropagationTargets);
        this._headersUrlMap.set(url2, decision);
        return decision;
      };
      if (shouldAttachTraceData(stringUrl)) {
        if (span) {
          const dynamicSamplingContext2 = _optionalChain._optionalChain([span, "optionalAccess", (_4) => _4.transaction, "optionalAccess", (_5) => _5.getDynamicSamplingContext, "call", (_6) => _6()]);
          const sentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext2);
          setHeadersOnRequest(request, span.toTraceparent(), sentryBaggageHeader);
        } else {
          const { traceId, sampled, dsc } = scope.getPropagationContext();
          const sentryTrace = tracing.generateSentryTraceHeader(traceId, void 0, sampled);
          const dynamicSamplingContext$1 = dsc || dynamicSamplingContext.getDynamicSamplingContextFromClient(traceId, client, scope);
          const sentryBaggageHeader = baggage.dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext$1);
          setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader);
        }
      }
    };
  }
  __init5() {
    this._onRequestEnd = (message) => {
      const hub$1 = hub.getCurrentHub();
      if (!hub$1.getIntegration(Undici)) {
        return;
      }
      const { request, response } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (http.isSentryRequest(stringUrl)) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setHttpStatus(response.statusCode);
        span.finish();
      }
      if (this._options.breadcrumbs) {
        hub$1.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              status_code: response.statusCode,
              url: stringUrl
            },
            type: "http"
          },
          {
            event: "response",
            request,
            response
          }
        );
      }
    };
  }
  __init6() {
    this._onRequestError = (message) => {
      const hub$1 = hub.getCurrentHub();
      if (!hub$1.getIntegration(Undici)) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (http.isSentryRequest(stringUrl)) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setStatus("internal_error");
        span.finish();
      }
      if (this._options.breadcrumbs) {
        hub$1.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              url: stringUrl
            },
            level: "error",
            type: "http"
          },
          {
            event: "error",
            request
          }
        );
      }
    };
  }
}
Undici.__initStatic();
function setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader) {
  if (request.__sentry_has_headers__) {
    return;
  }
  request.addHeader("sentry-trace", sentryTrace);
  if (sentryBaggageHeader) {
    request.addHeader("baggage", sentryBaggageHeader);
  }
  request.__sentry_has_headers__ = true;
}
function createRequestSpan(activeSpan, request, stringUrl) {
  const url$1 = url.parseUrl(stringUrl);
  const method = request.method || "GET";
  const data = {
    "http.method": method
  };
  if (url$1.search) {
    data["http.query"] = url$1.search;
  }
  if (url$1.hash) {
    data["http.fragment"] = url$1.hash;
  }
  return _optionalChain._optionalChain([activeSpan, "optionalAccess", (_7) => _7.startChild, "call", (_8) => _8({
    op: "http.client",
    origin: "auto.http.node.undici",
    description: `${method} ${url.getSanitizedUrlString(url$1)}`,
    data
  })]);
}
exports.Undici = Undici;
//# sourceMappingURL=index.cjs.map
