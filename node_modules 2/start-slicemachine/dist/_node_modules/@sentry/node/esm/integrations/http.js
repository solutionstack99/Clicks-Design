import "../../../../lru_map/lru.js";
import { NODE_VERSION } from "../nodeVersion.js";
import { normalizeRequestArgs, extractRawUrl, extractUrl, isSentryRequest, cleanSpanDescription } from "./utils/http.js";
import { _optionalChain } from './../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { logger } from './../../_node_modules/@sentry/utils/esm/logger.js';
import { fill } from './../../_node_modules/@sentry/utils/esm/object.js';
import { __exports as lru } from "../../../../../_virtual/lru.js";
import { getCurrentHub } from './../../_node_modules/@sentry/core/esm/hub.js';
import { generateSentryTraceHeader } from './../../_node_modules/@sentry/utils/esm/tracing.js';
import { getDynamicSamplingContextFromClient } from './../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js';
import { dynamicSamplingContextToSentryBaggageHeader } from './../../_node_modules/@sentry/utils/esm/baggage.js';
import { stringMatchesSomePattern } from './../../_node_modules/@sentry/utils/esm/string.js';
class Http {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Http";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = Http.id;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
    this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
    if (!this._breadcrumbs && !this._tracing) {
      return;
    }
    const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    if (clientOptions && clientOptions.instrumenter !== "sentry") {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("HTTP Integration is skipped because of instrumenter configuration.");
      return;
    }
    const shouldCreateSpanForRequest = (
      // eslint-disable-next-line deprecation/deprecation
      _optionalChain([this, "access", (_6) => _6._tracing, "optionalAccess", (_7) => _7.shouldCreateSpanForRequest]) || _optionalChain([clientOptions, "optionalAccess", (_8) => _8.shouldCreateSpanForRequest])
    );
    const tracePropagationTargets = _optionalChain([clientOptions, "optionalAccess", (_9) => _9.tracePropagationTargets]) || _optionalChain([this, "access", (_10) => _10._tracing, "optionalAccess", (_11) => _11.tracePropagationTargets]);
    const httpModule = require("http");
    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(
      httpModule,
      this._breadcrumbs,
      shouldCreateSpanForRequest,
      tracePropagationTargets
    );
    fill(httpModule, "get", wrappedHttpHandlerMaker);
    fill(httpModule, "request", wrappedHttpHandlerMaker);
    if (NODE_VERSION.major && NODE_VERSION.major > 8) {
      const httpsModule = require("https");
      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
        httpsModule,
        this._breadcrumbs,
        shouldCreateSpanForRequest,
        tracePropagationTargets
      );
      fill(httpsModule, "get", wrappedHttpsHandlerMaker);
      fill(httpsModule, "request", wrappedHttpsHandlerMaker);
    }
  }
}
Http.__initStatic();
function _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {
  const createSpanUrlMap = new lru.LRUMap(100);
  const headersUrlMap = new lru.LRUMap(100);
  const shouldCreateSpan = (url) => {
    if (shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = shouldCreateSpanForRequest(url);
    createSpanUrlMap.set(url, decision);
    return decision;
  };
  const shouldAttachTraceData = (url) => {
    if (tracePropagationTargets === void 0) {
      return true;
    }
    const cachedDecision = headersUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = stringMatchesSomePattern(url, tracePropagationTargets);
    headersUrlMap.set(url, decision);
    return decision;
  };
  function addRequestBreadcrumb(event, requestSpanData, req, res) {
    if (!getCurrentHub().getIntegration(Http)) {
      return;
    }
    getCurrentHub().addBreadcrumb(
      {
        category: "http",
        data: {
          status_code: res && res.statusCode,
          ...requestSpanData
        },
        type: "http"
      },
      {
        event,
        request: req,
        response: res
      }
    );
  }
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod(...args) {
      const requestArgs = normalizeRequestArgs(httpModule, args);
      const requestOptions = requestArgs[0];
      const rawRequestUrl = extractRawUrl(requestOptions);
      const requestUrl = extractUrl(requestOptions);
      if (isSentryRequest(requestUrl)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }
      const hub = getCurrentHub();
      const scope = hub.getScope();
      const parentSpan = scope.getSpan();
      const data = getRequestSpanData(requestUrl, requestOptions);
      const requestSpan = shouldCreateSpan(rawRequestUrl) ? _optionalChain([parentSpan, "optionalAccess", (_12) => _12.startChild, "call", (_13) => _13({
        op: "http.client",
        origin: "auto.http.node.http",
        description: `${data["http.method"]} ${data.url}`,
        data
      })]) : void 0;
      if (shouldAttachTraceData(rawRequestUrl)) {
        if (requestSpan) {
          const sentryTraceHeader = requestSpan.toTraceparent();
          const dynamicSamplingContext = _optionalChain([requestSpan, "optionalAccess", (_14) => _14.transaction, "optionalAccess", (_15) => _15.getDynamicSamplingContext, "call", (_16) => _16()]);
          addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext);
        } else {
          const client = hub.getClient();
          const { traceId, sampled, dsc } = scope.getPropagationContext();
          const sentryTraceHeader = generateSentryTraceHeader(traceId, void 0, sampled);
          const dynamicSamplingContext = dsc || (client ? getDynamicSamplingContextFromClient(traceId, client, scope) : void 0);
          addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext);
        }
      } else {
        (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
          `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
        );
      }
      return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("response", data, req, res);
        }
        if (requestSpan) {
          if (res.statusCode) {
            requestSpan.setHttpStatus(res.statusCode);
          }
          requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      }).once("error", function() {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("error", data, req);
        }
        if (requestSpan) {
          requestSpan.setHttpStatus(500);
          requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      });
    };
  };
}
function addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, dynamicSamplingContext) {
  const headers = requestOptions.headers || {};
  if (headers["sentry-trace"]) {
    return;
  }
  (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `);
  const sentryBaggage = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
  const sentryBaggageHeader = sentryBaggage && sentryBaggage.length > 0 ? normalizeBaggageHeader(requestOptions, sentryBaggage) : void 0;
  requestOptions.headers = {
    ...requestOptions.headers,
    "sentry-trace": sentryTraceHeader,
    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined
    ...sentryBaggageHeader && { baggage: sentryBaggageHeader }
  };
}
function getRequestSpanData(requestUrl, requestOptions) {
  const method = requestOptions.method || "GET";
  const data = {
    url: requestUrl,
    "http.method": method
  };
  if (requestOptions.hash) {
    data["http.fragment"] = requestOptions.hash.substring(1);
  }
  if (requestOptions.search) {
    data["http.query"] = requestOptions.search.substring(1);
  }
  return data;
}
function normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {
  if (!requestOptions.headers || !requestOptions.headers.baggage) {
    return sentryBaggageHeader;
  } else if (!sentryBaggageHeader) {
    return requestOptions.headers.baggage;
  } else if (Array.isArray(requestOptions.headers.baggage)) {
    return [...requestOptions.headers.baggage, sentryBaggageHeader];
  }
  return [requestOptions.headers.baggage, sentryBaggageHeader];
}
export {
  Http
};
//# sourceMappingURL=http.js.map
