{"version":3,"file":"contextlines.js","sources":["../../../../../../../../node_modules/@sentry/node/esm/integrations/contextlines.js"],"sourcesContent":["import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { addContextToFrame } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nconst FILE_CONTENT_CACHE = new LRUMap(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path) {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\n/** Add node modules / packages to the event */\nclass ContextLines  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'ContextLines';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = ContextLines.id;}\n\n   constructor(  _options = {}) {this._options = _options;ContextLines.prototype.__init.call(this);}\n\n  /** Get's the number of context lines to add */\n   get _contextLines() {\n    return this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    addGlobalEventProcessor(event => {\n      const self = getCurrentHub().getIntegration(ContextLines);\n      if (!self) {\n        return event;\n      }\n      return this.addSourceContext(event);\n    });\n  }\n\n  /** Processes an event and adds context lines */\n   async addSourceContext(event) {\n    // keep a lookup map of which files we've already enqueued to read,\n    // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n    const enqueuedReadSourceFileTasks = {};\n    const readSourceFileTasks = [];\n\n    if (this._contextLines > 0 && _optionalChain([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])) {\n      for (const exception of event.exception.values) {\n        if (!_optionalChain([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])) {\n          continue;\n        }\n\n        // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.\n        // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.\n        for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {\n          const frame = exception.stacktrace.frames[i];\n          // Call cache.get to bump the file to the top of the cache and ensure we have not already\n          // enqueued a read operation for this filename\n          if (\n            frame.filename &&\n            !enqueuedReadSourceFileTasks[frame.filename] &&\n            !FILE_CONTENT_CACHE.get(frame.filename)\n          ) {\n            readSourceFileTasks.push(_readSourceFile(frame.filename));\n            enqueuedReadSourceFileTasks[frame.filename] = 1;\n          }\n        }\n      }\n    }\n\n    // check if files to read > 0, if so, await all of them to be read before adding source contexts.\n    // Normally, Promise.all here could be short circuited if one of the promises rejects, but we\n    // are guarding from that by wrapping the i/o read operation in a try/catch.\n    if (readSourceFileTasks.length > 0) {\n      await Promise.all(readSourceFileTasks);\n    }\n\n    // Perform the same loop as above, but this time we can assume all files are in the cache\n    // and attempt to add source context to frames.\n    if (this._contextLines > 0 && _optionalChain([event, 'access', _6 => _6.exception, 'optionalAccess', _7 => _7.values])) {\n      for (const exception of event.exception.values) {\n        if (exception.stacktrace && exception.stacktrace.frames) {\n          await this.addSourceContextToFrames(exception.stacktrace.frames);\n        }\n      }\n    }\n\n    return event;\n  }\n\n  /** Adds context lines to frames */\n   addSourceContextToFrames(frames) {\n    for (const frame of frames) {\n      // Only add context if we have a filename and it hasn't already been added\n      if (frame.filename && frame.context_line === undefined) {\n        const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);\n\n        if (sourceFileLines) {\n          try {\n            addContextToFrame(sourceFileLines, frame, this._contextLines);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n      }\n    }\n  }\n}ContextLines.__initStatic();\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n * If reading fails, mark the file as null in the cache so we don't try again.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename) {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n\n  // We have already attempted to read this file and failed, do not try again\n  if (cachedFile === null) {\n    return null;\n  }\n\n  // We have a cache hit, return it\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  // Guard from throwing if readFile fails, this enables us to use Promise.all and\n  // not have it short circuiting if one of the promises rejects + since context lines are added\n  // on a best effort basis, we want to throw here anyways.\n\n  // If we made it to here, it means that our file is not cache nor marked as failed, so attempt to read it\n  let content = null;\n  try {\n    const rawFileContents = await readTextFileAsync(filename);\n    content = rawFileContents.split('\\n');\n  } catch (_) {\n    // if we fail, we will mark the file as null in the cache and short circuit next time we try to read it\n  }\n\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\n\nexport { ContextLines };\n//# sourceMappingURL=contextlines.js.map\n"],"names":["LRUMap"],"mappings":"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","x_google_ignoreList":[0]}