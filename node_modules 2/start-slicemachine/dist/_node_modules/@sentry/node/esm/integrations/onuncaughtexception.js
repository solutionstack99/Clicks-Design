import { logAndExitProcess } from "./utils/errorhandling.js";
import { getCurrentHub } from './../../_node_modules/@sentry/core/esm/hub.js';
import { logger } from './../../_node_modules/@sentry/utils/esm/logger.js';
class OnUncaughtException {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "OnUncaughtException";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = OnUncaughtException.id;
  }
  /**
   * @inheritDoc
   */
  __init2() {
    this.handler = this._makeErrorHandler();
  }
  // CAREFUL: Please think twice before updating the way _options looks because the Next.js SDK depends on it in `index.server.ts`
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    OnUncaughtException.prototype.__init.call(this);
    OnUncaughtException.prototype.__init2.call(this);
    this._options = {
      exitEvenIfOtherHandlersAreRegistered: true,
      ...options
    };
  }
  /**
   * @inheritDoc
   */
  setupOnce() {
    global.process.on("uncaughtException", this.handler);
  }
  /**
   * @hidden
   */
  _makeErrorHandler() {
    const timeout = 2e3;
    let caughtFirstError = false;
    let caughtSecondError = false;
    let calledFatalError = false;
    let firstError;
    return (error) => {
      let onFatalError = logAndExitProcess;
      const client = getCurrentHub().getClient();
      if (this._options.onFatalError) {
        onFatalError = this._options.onFatalError;
      } else if (client && client.getOptions().onFatalError) {
        onFatalError = client.getOptions().onFatalError;
      }
      const userProvidedListenersCount = global.process.listeners("uncaughtException").reduce((acc, listener) => {
        if (
          // There are 3 listeners we ignore:
          listener.name === "domainUncaughtExceptionClear" || // as soon as we're using domains this listener is attached by node itself
          listener.tag && listener.tag === "sentry_tracingErrorCallback" || // the handler we register for tracing
          listener === this.handler
        ) {
          return acc;
        } else {
          return acc + 1;
        }
      }, 0);
      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = this._options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;
      if (!caughtFirstError) {
        const hub = getCurrentHub();
        firstError = error;
        caughtFirstError = true;
        if (hub.getIntegration(OnUncaughtException)) {
          hub.withScope((scope) => {
            scope.setLevel("fatal");
            hub.captureException(error, {
              originalException: error,
              data: { mechanism: { handled: false, type: "onuncaughtexception" } }
            });
            if (!calledFatalError && shouldApplyFatalHandlingLogic) {
              calledFatalError = true;
              onFatalError(error);
            }
          });
        } else {
          if (!calledFatalError && shouldApplyFatalHandlingLogic) {
            calledFatalError = true;
            onFatalError(error);
          }
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.warn(
              "uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown"
            );
            logAndExitProcess(error);
          } else if (!caughtSecondError) {
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout);
          }
        }
      }
    };
  }
}
OnUncaughtException.__initStatic();
export {
  OnUncaughtException
};
//# sourceMappingURL=onuncaughtexception.js.map
