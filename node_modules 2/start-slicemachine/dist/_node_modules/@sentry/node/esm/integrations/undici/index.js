import "../../../../../lru_map/lru.js";
import { NODE_VERSION } from "../../nodeVersion.js";
import { isSentryRequest } from "../utils/http.js";
import { __exports as lru } from "../../../../../../_virtual/lru.js";
import { dynamicRequire } from './../../../_node_modules/@sentry/utils/esm/node.js';
import { getCurrentHub } from './../../../_node_modules/@sentry/core/esm/hub.js';
import { _optionalChain } from './../../../_node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js';
import { dynamicSamplingContextToSentryBaggageHeader } from './../../../_node_modules/@sentry/utils/esm/baggage.js';
import { generateSentryTraceHeader } from './../../../_node_modules/@sentry/utils/esm/tracing.js';
import { getDynamicSamplingContextFromClient } from './../../../_node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js';
import { parseUrl, getSanitizedUrlString } from './../../../_node_modules/@sentry/utils/esm/url.js';
import { stringMatchesSomePattern } from './../../../_node_modules/@sentry/utils/esm/string.js';
var ChannelName;
(function(ChannelName2) {
  const RequestCreate = "undici:request:create";
  ChannelName2["RequestCreate"] = RequestCreate;
  const RequestEnd = "undici:request:headers";
  ChannelName2["RequestEnd"] = RequestEnd;
  const RequestError = "undici:request:error";
  ChannelName2["RequestError"] = RequestError;
})(ChannelName || (ChannelName = {}));
class Undici {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Undici";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = Undici.id;
  }
  __init2() {
    this._createSpanUrlMap = new lru.LRUMap(100);
  }
  __init3() {
    this._headersUrlMap = new lru.LRUMap(100);
  }
  constructor(_options = {}) {
    Undici.prototype.__init.call(this);
    Undici.prototype.__init2.call(this);
    Undici.prototype.__init3.call(this);
    Undici.prototype.__init4.call(this);
    Undici.prototype.__init5.call(this);
    Undici.prototype.__init6.call(this);
    this._options = {
      breadcrumbs: _options.breadcrumbs === void 0 ? true : _options.breadcrumbs,
      shouldCreateSpanForRequest: _options.shouldCreateSpanForRequest
    };
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor) {
    if (NODE_VERSION.major && NODE_VERSION.major < 16) {
      return;
    }
    let ds;
    try {
      ds = dynamicRequire(module, "diagnostics_channel");
    } catch (e) {
    }
    if (!ds || !ds.subscribe) {
      return;
    }
    ds.subscribe(ChannelName.RequestCreate, this._onRequestCreate);
    ds.subscribe(ChannelName.RequestEnd, this._onRequestEnd);
    ds.subscribe(ChannelName.RequestError, this._onRequestError);
  }
  /** Helper that wraps shouldCreateSpanForRequest option */
  _shouldCreateSpan(url) {
    if (this._options.shouldCreateSpanForRequest === void 0) {
      return true;
    }
    const cachedDecision = this._createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = this._options.shouldCreateSpanForRequest(url);
    this._createSpanUrlMap.set(url, decision);
    return decision;
  }
  __init4() {
    this._onRequestCreate = (message) => {
      const hub = getCurrentHub();
      if (!hub.getIntegration(Undici)) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequest(stringUrl) || request.__sentry_span__ !== void 0) {
        return;
      }
      const client = hub.getClient();
      if (!client) {
        return;
      }
      const clientOptions = client.getOptions();
      const scope = hub.getScope();
      const parentSpan = scope.getSpan();
      const span = this._shouldCreateSpan(stringUrl) ? createRequestSpan(parentSpan, request, stringUrl) : void 0;
      if (span) {
        request.__sentry_span__ = span;
      }
      const shouldAttachTraceData = (url) => {
        if (clientOptions.tracePropagationTargets === void 0) {
          return true;
        }
        const cachedDecision = this._headersUrlMap.get(url);
        if (cachedDecision !== void 0) {
          return cachedDecision;
        }
        const decision = stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
        this._headersUrlMap.set(url, decision);
        return decision;
      };
      if (shouldAttachTraceData(stringUrl)) {
        if (span) {
          const dynamicSamplingContext = _optionalChain([span, "optionalAccess", (_4) => _4.transaction, "optionalAccess", (_5) => _5.getDynamicSamplingContext, "call", (_6) => _6()]);
          const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
          setHeadersOnRequest(request, span.toTraceparent(), sentryBaggageHeader);
        } else {
          const { traceId, sampled, dsc } = scope.getPropagationContext();
          const sentryTrace = generateSentryTraceHeader(traceId, void 0, sampled);
          const dynamicSamplingContext = dsc || getDynamicSamplingContextFromClient(traceId, client, scope);
          const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
          setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader);
        }
      }
    };
  }
  __init5() {
    this._onRequestEnd = (message) => {
      const hub = getCurrentHub();
      if (!hub.getIntegration(Undici)) {
        return;
      }
      const { request, response } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequest(stringUrl)) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setHttpStatus(response.statusCode);
        span.finish();
      }
      if (this._options.breadcrumbs) {
        hub.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              status_code: response.statusCode,
              url: stringUrl
            },
            type: "http"
          },
          {
            event: "response",
            request,
            response
          }
        );
      }
    };
  }
  __init6() {
    this._onRequestError = (message) => {
      const hub = getCurrentHub();
      if (!hub.getIntegration(Undici)) {
        return;
      }
      const { request } = message;
      const stringUrl = request.origin ? request.origin.toString() + request.path : request.path;
      if (isSentryRequest(stringUrl)) {
        return;
      }
      const span = request.__sentry_span__;
      if (span) {
        span.setStatus("internal_error");
        span.finish();
      }
      if (this._options.breadcrumbs) {
        hub.addBreadcrumb(
          {
            category: "http",
            data: {
              method: request.method,
              url: stringUrl
            },
            level: "error",
            type: "http"
          },
          {
            event: "error",
            request
          }
        );
      }
    };
  }
}
Undici.__initStatic();
function setHeadersOnRequest(request, sentryTrace, sentryBaggageHeader) {
  if (request.__sentry_has_headers__) {
    return;
  }
  request.addHeader("sentry-trace", sentryTrace);
  if (sentryBaggageHeader) {
    request.addHeader("baggage", sentryBaggageHeader);
  }
  request.__sentry_has_headers__ = true;
}
function createRequestSpan(activeSpan, request, stringUrl) {
  const url = parseUrl(stringUrl);
  const method = request.method || "GET";
  const data = {
    "http.method": method
  };
  if (url.search) {
    data["http.query"] = url.search;
  }
  if (url.hash) {
    data["http.fragment"] = url.hash;
  }
  return _optionalChain([activeSpan, "optionalAccess", (_7) => _7.startChild, "call", (_8) => _8({
    op: "http.client",
    origin: "auto.http.node.undici",
    description: `${method} ${getSanitizedUrlString(url)}`,
    data
  })]);
}
export {
  ChannelName,
  Undici
};
//# sourceMappingURL=index.js.map
