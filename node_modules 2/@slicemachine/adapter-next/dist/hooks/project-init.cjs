"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const fs = require("@slicemachine/plugin-kit/fs");
const commonTags = require("common-tags");
const checkHasAppRouter = require("../lib/checkHasAppRouter.cjs");
const checkHasSrcDirectory = require("../lib/checkHasSrcDirectory.cjs");
const checkIsTypeScriptProject = require("../lib/checkIsTypeScriptProject.cjs");
const getJSFileExtension = require("../lib/getJSFileExtension.cjs");
const rejectIfNecessary = require("../lib/rejectIfNecessary.cjs");
const constants = require("../constants.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
const installDependencies = async ({ installDependencies: installDependencies2 }) => {
  await installDependencies2({
    dependencies: {
      "@prismicio/client": "latest",
      "@prismicio/react": "latest",
      "@prismicio/next": "latest"
    }
  });
};
const createPrismicIOFile = async ({ helpers, options }) => {
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const hasAppRouter = await checkHasAppRouter.checkHasAppRouter({ helpers });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options });
  const filename = path__namespace.join(...[hasSrcDirectory ? "src" : void 0, `prismicio.${extension}`].filter((segment) => Boolean(segment)));
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  let createClientContents;
  if (hasAppRouter) {
    if (isTypeScriptProject) {
      createClientContents = commonTags.source`
				/**
				 * Creates a Prismic client for the project's repository. The client is used to
				 * query content from the Prismic API.
				 *
				 * @param config - Configuration for the Prismic client.
				 */
				export const createClient = (config: prismicNext.CreateClientConfig = {}) => {
					const client = prismic.createClient(repositoryName, {
						routes,
						fetchOptions:
							process.env.NODE_ENV === 'production'
								? { next: { tags: ['prismic'] }, cache: 'force-cache' }
								: { next: { revalidate: 5 } },
						...config,
					});

					prismicNext.enableAutoPreviews({
						client,
						previewData: config.previewData,
						req: config.req,
					});

					return client;
				};
			`;
    } else {
      createClientContents = commonTags.source`
				/**
				 * Creates a Prismic client for the project's repository. The client is used to
				 * query content from the Prismic API.
				 *
				 * @param {prismicNext.CreateClientConfig} config - Configuration for the Prismic client.
				 */
				export const createClient = (config = {}) => {
					const client = prismic.createClient(repositoryName, {
						routes,
						fetchOptions:
							process.env.NODE_ENV === 'production'
								? { next: { tags: ['prismic'] }, cache: 'force-cache' }
								: { next: { revalidate: 5 } },
						...config,
					});

					prismicNext.enableAutoPreviews({
						client,
						previewData: config.previewData,
						req: config.req,
					});

					return client;
				};
			`;
    }
  } else {
    if (isTypeScriptProject) {
      createClientContents = commonTags.source`
				/**
				 * Creates a Prismic client for the project's repository. The client is used to
				 * query content from the Prismic API.
				 *
				 * @param config - Configuration for the Prismic client.
				 */
				export const createClient = (config: prismicNext.CreateClientConfig = {}) => {
					const client = prismic.createClient(repositoryName, {
						routes,
						...config,
					});

					prismicNext.enableAutoPreviews({
						client,
						previewData: config.previewData,
						req: config.req,
					});

					return client;
				};
			`;
    } else {
      createClientContents = commonTags.source`
				/**
				 * Creates a Prismic client for the project's repository. The client is used to
				 * query content from the Prismic API.
				 *
				 * @param {prismicNext.CreateClientConfig} config - Configuration for the Prismic client.
				 */
				export const createClient = (config = {}) => {
					const client = prismic.createClient(repositoryName, {
						routes,
						...config,
					});

					prismicNext.enableAutoPreviews({
						client,
						previewData: config.previewData,
						req: config.req,
					});

					return client;
				};
			`;
    }
  }
  let contents;
  if (isTypeScriptProject) {
    contents = commonTags.source`
			import * as prismic from "@prismicio/client";
			import * as prismicNext from "@prismicio/next";
			import config from "${hasSrcDirectory ? ".." : "."}/slicemachine.config.json";

			/**
			 * The project's Prismic repository name.
			 */
			export const repositoryName =
				process.env.${constants.PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME} || config.repositoryName;

			/**
			 * A list of Route Resolver objects that define how a document's \`url\` field is resolved.
			 *
			 * {@link https://prismic.io/docs/route-resolver#route-resolver}
			 */
			// TODO: Update the routes array to match your project's route structure.
			const routes: prismic.ClientConfig["routes"] = [
				// Examples:
				// {
				// 	type: "homepage",
				// 	path: "/",
				// },
				// {
				// 	type: "page",
				// 	path: "/:uid",
				// },
			];

			${createClientContents}
		`;
  } else {
    contents = commonTags.source`
			import * as prismic from "@prismicio/client";
			import * as prismicNext from "@prismicio/next";
			import config from "${hasSrcDirectory ? ".." : "."}/slicemachine.config.json";

			/**
			 * The project's Prismic repository name.
			 */
			export const repositoryName =
				process.env.${constants.PRISMIC_ENVIRONMENT_ENVIRONMENT_VARIABLE_NAME} || config.repositoryName;

			/**
			 * A list of Route Resolver objects that define how a document's \`url\` field is resolved.
			 *
			 * {@link https://prismic.io/docs/route-resolver#route-resolver}
			 *
			 * @type {prismic.ClientConfig["routes"]}
			 */
			// TODO: Update the routes array to match your project's route structure.
			const routes = [
				// Examples:
				// {
				// 	type: "homepage",
				// 	path: "/",
				// },
				// {
				// 	type: "page",
				// 	path: "/:uid",
				// },
			];

			${createClientContents}
		`;
  }
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const createSliceSimulatorPage = async ({ helpers, options }) => {
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const hasAppRouter = await checkHasAppRouter.checkHasAppRouter({ helpers });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options, jsx: true });
  const filename = path__namespace.join(...[
    hasSrcDirectory ? "src" : void 0,
    hasAppRouter ? `app/slice-simulator/page.${extension}` : `pages/slice-simulator.${extension}`
  ].filter((segment) => Boolean(segment)));
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  let contents;
  if (hasAppRouter) {
    if (isTypeScriptProject) {
      contents = commonTags.source`
				import {
					SliceSimulator,
					SliceSimulatorParams,
					getSlices,
				} from "@slicemachine/adapter-next/simulator";
				import { SliceZone } from "@prismicio/react";

				import { components } from "../../slices";

				export default function SliceSimulatorPage({
					searchParams,
				}: SliceSimulatorParams) {
					const slices = getSlices(searchParams.state);

					return (
						<SliceSimulator>
							<SliceZone slices={slices} components={components} />
						</SliceSimulator>
					);
				}
			`;
    } else {
      contents = commonTags.source`
				import {
					SliceSimulator,
					getSlices,
				} from "@slicemachine/adapter-next/simulator";
				import { SliceZone } from "@prismicio/react";

				import { components } from "../../slices";

				export default function SliceSimulatorPage({ searchParams }) {
					const slices = getSlices(searchParams.state);

					return (
						<SliceSimulator>
							<SliceZone slices={slices} components={components} />
						</SliceSimulator>
					);
				}
			`;
    }
  } else {
    contents = commonTags.source`
			import { SliceSimulator } from "@slicemachine/adapter-next/simulator";
			import { SliceZone } from "@prismicio/react";

			import { components } from "../slices";

			export default function SliceSimulatorPage() {
				return (
					<SliceSimulator
						sliceZone={(props) => <SliceZone {...props} components={components} />}
					/>
				);
			}
		`;
  }
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const createPreviewRoute = async ({ helpers, options }) => {
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const hasAppRouter = await checkHasAppRouter.checkHasAppRouter({ helpers });
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options });
  const filename = path__namespace.join(...[
    hasSrcDirectory ? "src" : void 0,
    hasAppRouter ? `app/api/preview/route.${extension}` : `pages/api/preview.${extension}`
  ].filter((segment) => Boolean(segment)));
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  let contents;
  if (hasAppRouter) {
    if (isTypeScriptProject) {
      contents = commonTags.source`
				import { NextRequest } from "next/server";
				import { redirectToPreviewURL } from "@prismicio/next";

				import { createClient } from "../../../prismicio";

				export async function GET(request: NextRequest) {
					const client = createClient();

					return await redirectToPreviewURL({ client, request });
				}
			`;
    } else {
      contents = commonTags.source`
				import { redirectToPreviewURL } from "@prismicio/next";

				import { createClient } from "../../../prismicio";

				export async function GET(request) {
					const client = createClient();

					return await redirectToPreviewURL({ client, request });
				}
			`;
    }
  } else {
    if (isTypeScriptProject) {
      contents = commonTags.source`
				import { NextApiRequest, NextApiResponse } from "next";
				import { setPreviewData, redirectToPreviewURL } from "@prismicio/next";

				import { createClient } from "../../prismicio";

				export default async function handler(req: NextApiRequest, res: NextApiResponse) {
					const client = createClient({ req });

					await setPreviewData({ req, res });

					return await redirectToPreviewURL({ req, res, client });
				};
			`;
    } else {
      contents = commonTags.source`
				import { setPreviewData, redirectToPreviewURL } from "@prismicio/next";

				import { createClient } from "../../prismicio";

				export default async function handler(req, res) {
					const client = createClient({ req });

					await setPreviewData({ req, res });

					return await redirectToPreviewURL({ req, res, client });
				};
			`;
    }
  }
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const createExitPreviewRoute = async ({ helpers, options }) => {
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const hasAppRouter = await checkHasAppRouter.checkHasAppRouter({ helpers });
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options });
  const filename = path__namespace.join(...[
    hasSrcDirectory ? "src" : void 0,
    hasAppRouter ? `app/api/exit-preview/route.${extension}` : `pages/api/exit-preview.${extension}`
  ].filter((segment) => Boolean(segment)));
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  let contents;
  if (hasAppRouter) {
    contents = commonTags.source`
			import { exitPreview } from "@prismicio/next";

			export function GET() {
				return exitPreview();
			}
		`;
  } else {
    if (isTypeScriptProject) {
      contents = commonTags.source`
				import { NextApiRequest, NextApiResponse } from "next";
				import { exitPreview } from "@prismicio/next";

				export default function handler(req: NextApiRequest, res: NextApiResponse) {
					return exitPreview({ req, res });
				}
			`;
    } else {
      contents = commonTags.source`
				import { exitPreview } from "@prismicio/next";

				export default function handler(req, res) {
					return exitPreview({ req, res });
				}
			`;
    }
  }
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const modifySliceMachineConfig = async ({ helpers, options, actions }) => {
  var _a;
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const project = await helpers.getProject();
  (_a = project.config).localSliceSimulatorURL || (_a.localSliceSimulatorURL = "http://localhost:3000/slice-simulator");
  if (hasSrcDirectory && project.config.libraries && JSON.stringify(project.config.libraries) === JSON.stringify(["./slices"])) {
    const sliceLibrary = await actions.readSliceLibrary({
      libraryID: project.config.libraries[0]
    });
    if (sliceLibrary.sliceIDs.length < 1) {
      project.config.libraries = ["./src/slices"];
    }
  }
  await helpers.updateSliceMachineConfig(project.config, {
    format: options.format
  });
};
const createRevalidateRoute = async ({ helpers, options }) => {
  const hasAppRouter = await checkHasAppRouter.checkHasAppRouter({ helpers });
  if (!hasAppRouter) {
    return;
  }
  const hasSrcDirectory = await checkHasSrcDirectory.checkHasSrcDirectory({ helpers });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options });
  const filename = path__namespace.join(...[
    hasSrcDirectory ? "src" : void 0,
    `app/api/revalidate/route.${extension}`
  ].filter((segment) => Boolean(segment)));
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  const contents = commonTags.source`
		import { NextResponse } from "next/server";
		import { revalidateTag } from "next/cache";

		export async function POST() {
			revalidateTag("prismic");

			return NextResponse.json({ revalidated: true, now: Date.now() });
		}
	`;
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const projectInit = async ({ installDependencies: _installDependencies }, context) => {
  rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
    installDependencies({ installDependencies: _installDependencies }),
    modifySliceMachineConfig(context),
    createPrismicIOFile(context),
    createSliceSimulatorPage(context),
    createPreviewRoute(context),
    createExitPreviewRoute(context),
    createRevalidateRoute(context)
  ]));
};
exports.projectInit = projectInit;
//# sourceMappingURL=project-init.cjs.map
